WEBVTT

00:00:00.000 --> 00:00:04.940 align:middle line:84%
[SQUEAKING]
[RUSTLING] [CLICKING]

00:00:04.940 --> 00:00:16.796 align:middle line:90%


00:00:16.796 --> 00:00:21.690 align:middle line:84%
ANA BELL: OK, let's get
started with today's lecture.

00:00:21.690 --> 00:00:24.680 align:middle line:84%
It's going to be more
of a chill lecture

00:00:24.680 --> 00:00:26.460 align:middle line:84%
than what we've
done in the past,

00:00:26.460 --> 00:00:28.910 align:middle line:84%
even though we've got quite
a few things to cover,

00:00:28.910 --> 00:00:31.370 align:middle line:84%
as you can see from
this title slide.

00:00:31.370 --> 00:00:33.440 align:middle line:84%
I'm not going to go
super duper fast,

00:00:33.440 --> 00:00:35.610 align:middle line:84%
so please feel free to
ask lots of questions.

00:00:35.610 --> 00:00:37.423 align:middle line:84%
And then the second
half of the lecture

00:00:37.423 --> 00:00:38.840 align:middle line:84%
will be really
chill because we're

00:00:38.840 --> 00:00:41.420 align:middle line:84%
going to be talking about
testing and debugging

00:00:41.420 --> 00:00:45.180 align:middle line:84%
strategies, so super
high-level topic.

00:00:45.180 --> 00:00:48.740 align:middle line:84%
But first we're going to tie
up some loose ends related

00:00:48.740 --> 00:00:52.050 align:middle line:84%
to lists and relating
to functions.

00:00:52.050 --> 00:00:55.160 align:middle line:84%
So we're not going to
introduce a lot of new syntax.

00:00:55.160 --> 00:00:59.210 align:middle line:84%
These ideas are more optional
in your day-to-day coding,

00:00:59.210 --> 00:01:01.950 align:middle line:84%
but they're just really,
really nice to know.

00:01:01.950 --> 00:01:05.480 align:middle line:84%
So let's first start talking
about this idea of a list

00:01:05.480 --> 00:01:08.310 align:middle line:90%
comprehension.

00:01:08.310 --> 00:01:12.620 align:middle line:84%
So you've been writing
functions that deal with lists.

00:01:12.620 --> 00:01:17.210 align:middle line:84%
And one really common pattern
that I hope you've seen so far

00:01:17.210 --> 00:01:18.660 align:middle line:90%
is the following.

00:01:18.660 --> 00:01:20.930 align:middle line:84%
So this code right
here shows something

00:01:20.930 --> 00:01:22.910 align:middle line:84%
that we've definitely
coded together

00:01:22.910 --> 00:01:24.950 align:middle line:84%
and you've definitely
coded in the finger

00:01:24.950 --> 00:01:27.080 align:middle line:90%
exercises and the quizzes.

00:01:27.080 --> 00:01:29.130 align:middle line:84%
And so it is a really
common pattern.

00:01:29.130 --> 00:01:32.480 align:middle line:84%
So the idea here is you
have a function that

00:01:32.480 --> 00:01:35.480 align:middle line:84%
creates a new list where the
elements of this new list

00:01:35.480 --> 00:01:38.090 align:middle line:84%
are a function of
the input list.

00:01:38.090 --> 00:01:41.750 align:middle line:84%
So the pattern here is we
create a new empty list

00:01:41.750 --> 00:01:43.370 align:middle line:90%
inside the function.

00:01:43.370 --> 00:01:46.730 align:middle line:84%
We have a loop over every
element in the input.

00:01:46.730 --> 00:01:49.040 align:middle line:84%
And to each one of these
elements in the input

00:01:49.040 --> 00:01:50.700 align:middle line:90%
we apply the same function.

00:01:50.700 --> 00:01:53.270 align:middle line:84%
So in this particular case,
we're taking that element

00:01:53.270 --> 00:01:54.680 align:middle line:90%
and squaring it.

00:01:54.680 --> 00:01:56.480 align:middle line:84%
And each one of
these elements we're

00:01:56.480 --> 00:01:59.870 align:middle line:84%
appending to this new
list, originally empty,

00:01:59.870 --> 00:02:03.680 align:middle line:84%
until we've done this function
to every element in L,

00:02:03.680 --> 00:02:07.580 align:middle line:84%
and then we return this
newly created list.

00:02:07.580 --> 00:02:11.850 align:middle line:84%
So since this is a really common
thing that programmers do,

00:02:11.850 --> 00:02:16.320 align:middle line:84%
Python allows you to do
this exact functionality

00:02:16.320 --> 00:02:18.330 align:middle line:90%
with one line of code.

00:02:18.330 --> 00:02:21.150 align:middle line:84%
And the way we do this
is using something

00:02:21.150 --> 00:02:23.020 align:middle line:90%
called a list comprehension.

00:02:23.020 --> 00:02:26.250 align:middle line:84%
So the way that we do a list
comprehension, essentially

00:02:26.250 --> 00:02:29.190 align:middle line:84%
taking these four lines of
code from this function,

00:02:29.190 --> 00:02:33.870 align:middle line:84%
we are going to write them
in this one line of code that

00:02:33.870 --> 00:02:35.700 align:middle line:90%
looks something like this.

00:02:35.700 --> 00:02:38.350 align:middle line:84%
So the idea here is with
this one line of code,

00:02:38.350 --> 00:02:41.280 align:middle line:84%
we're going to
create a new list.

00:02:41.280 --> 00:02:43.790 align:middle line:84%
We're going to have
an iterator that

00:02:43.790 --> 00:02:46.410 align:middle line:84%
goes through some sort
of sequence of values,

00:02:46.410 --> 00:02:48.920 align:middle line:84%
and we're going to
apply the same function

00:02:48.920 --> 00:02:50.630 align:middle line:90%
to every one of those elements.

00:02:50.630 --> 00:02:52.730 align:middle line:84%
And the other
optional piece that we

00:02:52.730 --> 00:02:55.130 align:middle line:84%
can add inside this
list comprehension

00:02:55.130 --> 00:02:59.270 align:middle line:84%
is to only apply that function
if some condition holds.

00:02:59.270 --> 00:03:02.060 align:middle line:90%
So let's look at this--

00:03:02.060 --> 00:03:04.190 align:middle line:84%
let's look at this
example and see

00:03:04.190 --> 00:03:07.430 align:middle line:84%
how we can convert
these four lines of code

00:03:07.430 --> 00:03:11.510 align:middle line:84%
to one line of list
comprehension code.

00:03:11.510 --> 00:03:16.170 align:middle line:84%
So we've got creating
a new empty list.

00:03:16.170 --> 00:03:23.200 align:middle line:84%
This is going to tell Python to
create a new empty list for us.

00:03:23.200 --> 00:03:25.500 align:middle line:84%
So just open and
close square brackets.

00:03:25.500 --> 00:03:28.020 align:middle line:84%
And within these open and
closed square brackets,

00:03:28.020 --> 00:03:31.440 align:middle line:84%
we're going to write a
one-liner expression.

00:03:31.440 --> 00:03:34.320 align:middle line:84%
And this one liner is
going to encapsulate

00:03:34.320 --> 00:03:37.900 align:middle line:90%
these two lines of code here.

00:03:37.900 --> 00:03:41.250 align:middle line:84%
So the expression--
sorry, the function

00:03:41.250 --> 00:03:43.680 align:middle line:84%
we're going to apply
to every element in L

00:03:43.680 --> 00:03:46.435 align:middle line:84%
is going to be taking that
element and squaring it.

00:03:46.435 --> 00:03:48.810 align:middle line:84%
So on the right-hand side here
in the list comprehension,

00:03:48.810 --> 00:03:51.560 align:middle line:90%
we've got some e squared.

00:03:51.560 --> 00:03:52.970 align:middle line:90%
Well, what is e?

00:03:52.970 --> 00:03:57.530 align:middle line:84%
Well, it's going to be
every element e in L.

00:03:57.530 --> 00:03:59.660 align:middle line:84%
So if we read this in
English, we basically

00:03:59.660 --> 00:04:04.520 align:middle line:84%
say Lnew is going to contain
elements e squared for e in L.

00:04:04.520 --> 00:04:07.280 align:middle line:84%
So it sounds weird, but
it kind of makes sense,

00:04:07.280 --> 00:04:09.540 align:middle line:90%
even if we read it in English.

00:04:09.540 --> 00:04:13.620 align:middle line:84%
And behind the scenes,
Python will take one by one

00:04:13.620 --> 00:04:16.079 align:middle line:90%
each element in L, square it.

00:04:16.079 --> 00:04:17.970 align:middle line:84%
And that's the
sequence of elements it

00:04:17.970 --> 00:04:20.744 align:middle line:90%
will populate this Lnew with.

00:04:20.744 --> 00:04:23.550 align:middle line:90%


00:04:23.550 --> 00:04:25.870 align:middle line:84%
Now, what if we add
a condition to that?

00:04:25.870 --> 00:04:29.370 align:middle line:84%
So let's say we want to create
this new list of elements

00:04:29.370 --> 00:04:32.790 align:middle line:90%
only for even elements.

00:04:32.790 --> 00:04:35.120 align:middle line:84%
So we only want to
square the even elements

00:04:35.120 --> 00:04:38.360 align:middle line:84%
within my original
list L. Well, if we

00:04:38.360 --> 00:04:41.570 align:middle line:84%
were to write a function that
does that, we have to add

00:04:41.570 --> 00:04:43.200 align:middle line:90%
this extra condition here.

00:04:43.200 --> 00:04:46.805 align:middle line:84%
So everything else is the same
except for this if e%2 equal

00:04:46.805 --> 00:04:47.570 align:middle line:90%
to 0.

00:04:47.570 --> 00:04:50.810 align:middle line:84%
This tells Python to
only grab elements

00:04:50.810 --> 00:04:54.640 align:middle line:90%
that are even, divisible by 2.

00:04:54.640 --> 00:04:57.830 align:middle line:84%
So how do we write this in
list comprehension form?

00:04:57.830 --> 00:04:59.290 align:middle line:90%
So here's a new list.

00:04:59.290 --> 00:05:02.650 align:middle line:84%
And this is the function to
apply only if the test is true.

00:05:02.650 --> 00:05:06.430 align:middle line:84%
In list comprehension,
this is my new list.

00:05:06.430 --> 00:05:09.880 align:middle line:84%
I've got the for
loop is over here.

00:05:09.880 --> 00:05:16.915 align:middle line:84%
And then the test to apply is at
the end here, if e%2 equals 0.

00:05:16.915 --> 00:05:18.790 align:middle line:84%
And then what is the
function we're applying?

00:05:18.790 --> 00:05:20.620 align:middle line:90%
It's just e squared like before.

00:05:20.620 --> 00:05:24.460 align:middle line:84%
So the test just gets appended
to the end of this list

00:05:24.460 --> 00:05:28.540 align:middle line:90%
comprehension expression here.

00:05:28.540 --> 00:05:29.636 align:middle line:90%
Yeah.

00:05:29.636 --> 00:05:31.680 align:middle line:84%
AUDIENCE: I see
it running faster.

00:05:31.680 --> 00:05:33.060 align:middle line:90%
Is there a reason to do that?

00:05:33.060 --> 00:05:35.170 align:middle line:90%
ANA BELL: Does it run faster?

00:05:35.170 --> 00:05:36.510 align:middle line:90%
I'm not sure, actually.

00:05:36.510 --> 00:05:40.710 align:middle line:84%
It might run marginally faster
but probably not significantly.

00:05:40.710 --> 00:05:44.580 align:middle line:84%
The reason to do this
is because as you

00:05:44.580 --> 00:05:48.300 align:middle line:84%
get more practice with it, this
will be easier to read in code.

00:05:48.300 --> 00:05:52.270 align:middle line:84%
And often, if you see a
large chunk like this,

00:05:52.270 --> 00:05:53.745 align:middle line:90%
your eyes will glaze over.

00:05:53.745 --> 00:05:55.870 align:middle line:84%
You're not going to want
to read a chunk like that.

00:05:55.870 --> 00:05:58.110 align:middle line:84%
But if you see it
all in one line,

00:05:58.110 --> 00:06:01.420 align:middle line:84%
you're going to think,
well, how bad can it be?

00:06:01.420 --> 00:06:04.620 align:middle line:84%
And so you can come up with
really complicated list

00:06:04.620 --> 00:06:06.390 align:middle line:90%
comprehension expressions.

00:06:06.390 --> 00:06:11.130 align:middle line:84%
But usually, we reserve them
for really simple, really quick

00:06:11.130 --> 00:06:13.440 align:middle line:84%
ways to create these
lists that you just

00:06:13.440 --> 00:06:16.432 align:middle line:84%
populate with some
values right off the bat.

00:06:16.432 --> 00:06:18.390 align:middle line:84%
So it just makes the code
a lot easier to read.

00:06:18.390 --> 00:06:22.190 align:middle line:90%


00:06:22.190 --> 00:06:25.433 align:middle line:84%
So list comprehensions
are pretty useful.

00:06:25.433 --> 00:06:27.350 align:middle line:84%
If you get a little bit
of practice with them,

00:06:27.350 --> 00:06:30.840 align:middle line:84%
you'll find yourself kind of
using them all over the place.

00:06:30.840 --> 00:06:35.460 align:middle line:84%
And they basically replace
code that looks like this.

00:06:35.460 --> 00:06:38.870 align:middle line:84%
So these lines of code
is a very generic way

00:06:38.870 --> 00:06:43.380 align:middle line:84%
of writing this one-liner
list comprehension.

00:06:43.380 --> 00:06:47.210 align:middle line:84%
So here I've got a function
f that I would like to apply.

00:06:47.210 --> 00:06:51.380 align:middle line:84%
This expr, expression,
is the function

00:06:51.380 --> 00:06:53.430 align:middle line:84%
I would like to apply
to each element.

00:06:53.430 --> 00:06:56.750 align:middle line:84%
This is the list I would like
to apply that function to.

00:06:56.750 --> 00:07:00.260 align:middle line:84%
And the test is going
to be the conditional.

00:07:00.260 --> 00:07:03.020 align:middle line:84%
In this particular
case, this test

00:07:03.020 --> 00:07:05.360 align:middle line:84%
means I apply it to
every single element.

00:07:05.360 --> 00:07:08.360 align:middle line:84%
But you can imagine
having a function which,

00:07:08.360 --> 00:07:12.440 align:middle line:84%
in the previous case, we
would say lambda x%2 equals 0

00:07:12.440 --> 00:07:13.850 align:middle line:90%
as our condition.

00:07:13.850 --> 00:07:16.820 align:middle line:84%
And then the function that
we're essentially replacing

00:07:16.820 --> 00:07:19.820 align:middle line:84%
is this with list
comprehensions.

00:07:19.820 --> 00:07:21.020 align:middle line:90%
We create this new list.

00:07:21.020 --> 00:07:24.230 align:middle line:84%
Again, this is the pattern that
we saw in the previous slide.

00:07:24.230 --> 00:07:26.390 align:middle line:84%
We loop through every
element in the list.

00:07:26.390 --> 00:07:30.020 align:middle line:84%
If that condition holds,
append that function

00:07:30.020 --> 00:07:31.550 align:middle line:90%
applied to each element.

00:07:31.550 --> 00:07:34.340 align:middle line:84%
And then at the end,
return the list.

00:07:34.340 --> 00:07:36.260 align:middle line:84%
So this is just a
very generic way

00:07:36.260 --> 00:07:39.290 align:middle line:90%
to write a list comprehension.

00:07:39.290 --> 00:07:41.300 align:middle line:84%
So let's look at some
concrete examples.

00:07:41.300 --> 00:07:45.700 align:middle line:84%
So here, I'm not
applying the function

00:07:45.700 --> 00:07:49.270 align:middle line:84%
e squared to a particular
set of elements from a list.

00:07:49.270 --> 00:07:53.320 align:middle line:84%
I'm applying it to the sequence
of values given by range.

00:07:53.320 --> 00:07:55.780 align:middle line:84%
Remember, when we were talking
about for loops iterating

00:07:55.780 --> 00:07:59.650 align:middle line:84%
through things, they can iterate
through integers following

00:07:59.650 --> 00:08:03.370 align:middle line:84%
some pattern, like
range 6, range 1 comma 9

00:08:03.370 --> 00:08:04.990 align:middle line:90%
comma 2, something like that.

00:08:04.990 --> 00:08:08.050 align:middle line:84%
As long as you have a sequence
of values you can iterate over,

00:08:08.050 --> 00:08:11.840 align:middle line:84%
you can plop that into
this list comprehension.

00:08:11.840 --> 00:08:13.390 align:middle line:90%
So you can iterate over lists.

00:08:13.390 --> 00:08:14.980 align:middle line:90%
You could iterate over tuples.

00:08:14.980 --> 00:08:18.310 align:middle line:84%
You could iterate over
these direct ranges.

00:08:18.310 --> 00:08:20.780 align:middle line:84%
You could iterate over a
range of the length of a list.

00:08:20.780 --> 00:08:23.320 align:middle line:84%
Whatever creates an
iterable for you,

00:08:23.320 --> 00:08:26.690 align:middle line:84%
you can put that in
the list comprehension.

00:08:26.690 --> 00:08:29.980 align:middle line:84%
So in this particular case,
the way I read this is I've

00:08:29.980 --> 00:08:31.510 align:middle line:90%
got something that I'm squaring.

00:08:31.510 --> 00:08:33.370 align:middle line:84%
And what's the thing
that I'm squaring?

00:08:33.370 --> 00:08:36.490 align:middle line:84%
It's going to be each
value in range 6.

00:08:36.490 --> 00:08:39.559 align:middle line:84%
So I think about it like,
what is the sequence of values

00:08:39.559 --> 00:08:40.789 align:middle line:90%
that I'm going to operate on?

00:08:40.789 --> 00:08:44.020 align:middle line:84%
Well, it's going to be the
numbers 0, 1, 2, 3, 4, 5.

00:08:44.020 --> 00:08:45.770 align:middle line:84%
And the thing that I'm
going to do to them

00:08:45.770 --> 00:08:48.060 align:middle line:84%
is square each one
of those values.

00:08:48.060 --> 00:08:51.680 align:middle line:84%
So the end list that I get
out of this one liner here

00:08:51.680 --> 00:08:55.460 align:middle line:84%
is a list containing 0
squared, 1 squared, 2 squared,

00:08:55.460 --> 00:08:59.180 align:middle line:84%
3 squared, 4 squared,
and 5 squared.

00:08:59.180 --> 00:09:00.900 align:middle line:90%
We can add a condition to that.

00:09:00.900 --> 00:09:05.360 align:middle line:84%
So here I've got each element
squared for e in range 8

00:09:05.360 --> 00:09:09.170 align:middle line:90%
only if e is even.

00:09:09.170 --> 00:09:12.380 align:middle line:84%
So then the way I think about
it is let's start off with what

00:09:12.380 --> 00:09:13.820 align:middle line:90%
every element in the range is.

00:09:13.820 --> 00:09:16.640 align:middle line:84%
Well, it's 0, 1,
2, 3, 4, 5 6, 7.

00:09:16.640 --> 00:09:19.490 align:middle line:84%
The condition I'm applying
to that is that it's even.

00:09:19.490 --> 00:09:21.560 align:middle line:84%
So the numbers I'm
going to end up

00:09:21.560 --> 00:09:25.160 align:middle line:84%
with, I'm filtering all
those to only contain

00:09:25.160 --> 00:09:30.080 align:middle line:84%
0, 2, 4, and 6 because we go
up to but not including 8.

00:09:30.080 --> 00:09:32.490 align:middle line:84%
And then I'm going to
square every one of those.

00:09:32.490 --> 00:09:34.820 align:middle line:84%
So the end result from
this list comprehension

00:09:34.820 --> 00:09:37.880 align:middle line:84%
is a list containing the
elements 0 squared, 2 squared,

00:09:37.880 --> 00:09:39.875 align:middle line:90%
4 squared, and 6 squared.

00:09:39.875 --> 00:09:42.750 align:middle line:90%


00:09:42.750 --> 00:09:47.510 align:middle line:84%
And lastly, we've been
doing just single integers

00:09:47.510 --> 00:09:48.800 align:middle line:90%
in the resulting list.

00:09:48.800 --> 00:09:52.440 align:middle line:84%
But as I mentioned, we can
do more complicated things.

00:09:52.440 --> 00:09:55.550 align:middle line:84%
So as long as we can write
a little expression here

00:09:55.550 --> 00:09:59.060 align:middle line:84%
for the thing that we'd like to
calculate or add to the list,

00:09:59.060 --> 00:10:01.770 align:middle line:84%
we can put it in the
list comprehension.

00:10:01.770 --> 00:10:04.040 align:middle line:84%
So in this particular
case, the element

00:10:04.040 --> 00:10:08.090 align:middle line:84%
that I'm adding to my list
comprehension or my resulting

00:10:08.090 --> 00:10:11.520 align:middle line:84%
list from the list
comprehension is a list itself.

00:10:11.520 --> 00:10:16.190 align:middle line:84%
So each element in my resulting
list is another list, right?

00:10:16.190 --> 00:10:18.470 align:middle line:84%
And that inner list
is going to contain

00:10:18.470 --> 00:10:21.980 align:middle line:84%
two elements every time,
the thing I'm actually

00:10:21.980 --> 00:10:24.440 align:middle line:90%
iterating over and its square.

00:10:24.440 --> 00:10:27.390 align:middle line:90%


00:10:27.390 --> 00:10:29.560 align:middle line:90%
And I've got a condition here.

00:10:29.560 --> 00:10:32.730 align:middle line:84%
So I've got the
elements 0, 1, 2, and 3.

00:10:32.730 --> 00:10:34.350 align:middle line:90%
That's the range.

00:10:34.350 --> 00:10:38.020 align:middle line:84%
But I'm only grabbing the odd
ones in this particular case.

00:10:38.020 --> 00:10:43.930 align:middle line:84%
So the resulting set of numbers
that I'm going to apply this to

00:10:43.930 --> 00:10:46.500 align:middle line:90%
is going to be the number--

00:10:46.500 --> 00:10:50.490 align:middle line:84%
is the numbers 1 and
3 because those are

00:10:50.490 --> 00:10:53.430 align:middle line:90%
the two odd numbers in range 4.

00:10:53.430 --> 00:10:57.910 align:middle line:84%
And so the resulting list is
going to contain two elements.

00:10:57.910 --> 00:11:01.410 align:middle line:84%
So this outer square bracket
is the list that I've created.

00:11:01.410 --> 00:11:06.330 align:middle line:84%
And its elements will be the
element that I have actually

00:11:06.330 --> 00:11:12.180 align:middle line:84%
iterated over and its square
as a list, so 1 and 1 squared

00:11:12.180 --> 00:11:18.510 align:middle line:84%
for e and e squared when e is
1 and then 3 and 9, 3 squared,

00:11:18.510 --> 00:11:19.860 align:middle line:90%
when e is 3.

00:11:19.860 --> 00:11:22.860 align:middle line:90%


00:11:22.860 --> 00:11:23.910 align:middle line:90%
Questions about that?

00:11:23.910 --> 00:11:26.490 align:middle line:90%


00:11:26.490 --> 00:11:27.300 align:middle line:90%
OK.

00:11:27.300 --> 00:11:28.770 align:middle line:90%
So pretty cool.

00:11:28.770 --> 00:11:31.260 align:middle line:84%
It's a really nice way to
create lists really quickly.

00:11:31.260 --> 00:11:34.410 align:middle line:84%
Like, if you wanted to
create a list full of zeros,

00:11:34.410 --> 00:11:37.440 align:middle line:84%
full of a hundred zeros,
no need to do a loop.

00:11:37.440 --> 00:11:39.240 align:middle line:84%
You basically do a
list comprehension

00:11:39.240 --> 00:11:43.030 align:middle line:84%
that says square brackets
0 for e in range 101--

00:11:43.030 --> 00:11:45.090 align:middle line:90%
or 100.

00:11:45.090 --> 00:11:47.310 align:middle line:84%
And then you've got
yourself a nice little list

00:11:47.310 --> 00:11:48.435 align:middle line:90%
full of a hundred zeros.

00:11:48.435 --> 00:11:50.980 align:middle line:90%


00:11:50.980 --> 00:11:54.310 align:middle line:84%
All right, so think about
this and then tell me

00:11:54.310 --> 00:11:55.670 align:middle line:90%
what the answer is.

00:11:55.670 --> 00:12:00.100 align:middle line:84%
So the idea here is we have
this list comprehension.

00:12:00.100 --> 00:12:03.160 align:middle line:84%
And just go through
it step by step.

00:12:03.160 --> 00:12:04.810 align:middle line:84%
It looks a little
bit intimidating.

00:12:04.810 --> 00:12:07.450 align:middle line:84%
But the first step is
to look at for loop

00:12:07.450 --> 00:12:10.900 align:middle line:84%
and ask yourself, what are
the values I'm iterating over?

00:12:10.900 --> 00:12:13.840 align:middle line:84%
Then look at the
condition if there is one.

00:12:13.840 --> 00:12:15.380 align:middle line:90%
There is one in this case.

00:12:15.380 --> 00:12:16.280 align:middle line:90%
It's at the end here.

00:12:16.280 --> 00:12:18.580 align:middle line:84%
So now what subsets of
those original things

00:12:18.580 --> 00:12:21.070 align:middle line:84%
you're iterating over
are you actually keeping?

00:12:21.070 --> 00:12:23.530 align:middle line:84%
And then from those things
that you're keeping,

00:12:23.530 --> 00:12:25.360 align:middle line:90%
what function are you applying?

00:12:25.360 --> 00:12:28.200 align:middle line:84%
It's the one right
at the beginning.

00:12:28.200 --> 00:12:29.320 align:middle line:90%
So think about it.

00:12:29.320 --> 00:12:31.230 align:middle line:84%
And then I'll ask
you to tell me.

00:12:31.230 --> 00:12:35.130 align:middle line:90%


00:12:35.130 --> 00:12:38.370 align:middle line:84%
So step one, what are the
values I'm iterating over,

00:12:38.370 --> 00:12:42.730 align:middle line:84%
the full values, not
including the condition?

00:12:42.730 --> 00:12:43.780 align:middle line:90%
Someone yell it out.

00:12:43.780 --> 00:12:46.310 align:middle line:90%


00:12:46.310 --> 00:12:48.020 align:middle line:84%
Yeah, that list in
the middle, awesome.

00:12:48.020 --> 00:12:56.390 align:middle line:90%
OK, so xy, abcd, and then 7.

00:12:56.390 --> 00:12:58.040 align:middle line:90%
And then what's the last thing?

00:12:58.040 --> 00:12:59.972 align:middle line:84%
Is it the number
4.0 or a string?

00:12:59.972 --> 00:13:00.680 align:middle line:90%
AUDIENCE: String.

00:13:00.680 --> 00:13:02.990 align:middle line:90%
ANA BELL: Yeah, exactly, 4.0.

00:13:02.990 --> 00:13:05.240 align:middle line:90%
OK, string, string.

00:13:05.240 --> 00:13:07.700 align:middle line:84%
Step two, from
this list, what are

00:13:07.700 --> 00:13:11.984 align:middle line:84%
the values that I'm actually
keeping based on the condition?

00:13:11.984 --> 00:13:13.234 align:middle line:90%
AUDIENCE: If they're a string.

00:13:13.234 --> 00:13:14.610 align:middle line:90%
ANA BELL: If they're a string.

00:13:14.610 --> 00:13:15.943 align:middle line:90%
All right, which one's a string?

00:13:15.943 --> 00:13:16.980 align:middle line:90%
Is xy?

00:13:16.980 --> 00:13:17.820 align:middle line:90%
Yes.

00:13:17.820 --> 00:13:19.650 align:middle line:90%
Is abcd?

00:13:19.650 --> 00:13:21.080 align:middle line:90%
Yep.

00:13:21.080 --> 00:13:22.440 align:middle line:90%
Is 7?

00:13:22.440 --> 00:13:22.940 align:middle line:90%
Nope.

00:13:22.940 --> 00:13:24.780 align:middle line:90%
Is 4.0?

00:13:24.780 --> 00:13:25.710 align:middle line:90%
Yes, excellent.

00:13:25.710 --> 00:13:27.170 align:middle line:90%
OK, good.

00:13:27.170 --> 00:13:29.900 align:middle line:84%
OK, so then these are the
elements that I'm keeping.

00:13:29.900 --> 00:13:31.670 align:middle line:84%
And now what's the
function I'm applying?

00:13:31.670 --> 00:13:33.710 align:middle line:84%
And what's the
result going to be?

00:13:33.710 --> 00:13:35.750 align:middle line:84%
It's going to be a
list containing--

00:13:35.750 --> 00:13:38.060 align:middle line:90%
AUDIENCE: 2, 4, 3.

00:13:38.060 --> 00:13:39.736 align:middle line:90%
ANA BELL: Yeah, 3--

00:13:39.736 --> 00:13:41.400 align:middle line:90%
AUDIENCE: 2, 4, 3.

00:13:41.400 --> 00:13:42.260 align:middle line:90%
ANA BELL: 2, 4, 3.

00:13:42.260 --> 00:13:46.160 align:middle line:84%
2 because that's length 2, 4
because that's length 4, and 3

00:13:46.160 --> 00:13:48.240 align:middle line:90%
because that's length 3.

00:13:48.240 --> 00:13:48.740 align:middle line:90%
Great.

00:13:48.740 --> 00:13:51.200 align:middle line:84%
And we've got ourselves
a nice little list based

00:13:51.200 --> 00:13:54.740 align:middle line:84%
on that condition, that
sequence of values,

00:13:54.740 --> 00:13:56.150 align:middle line:90%
and that function applied.

00:13:56.150 --> 00:13:56.650 align:middle line:90%
Yeah.

00:13:56.650 --> 00:13:58.150 align:middle line:84%
AUDIENCE: Why does
it return a list?

00:13:58.150 --> 00:14:00.590 align:middle line:84%
ANA BELL: Why does
it return a list?

00:14:00.590 --> 00:14:01.760 align:middle line:90%
The whole thing?

00:14:01.760 --> 00:14:05.130 align:middle line:84%
AUDIENCE: Or I guess I
thought it would return 2, 4,

00:14:05.130 --> 00:14:06.540 align:middle line:90%
3 on separate lines.

00:14:06.540 --> 00:14:09.290 align:middle line:84%
ANA BELL: Oh, yeah, so we're
not printing things out here.

00:14:09.290 --> 00:14:11.990 align:middle line:84%
When we're writing this
as a list comprehension,

00:14:11.990 --> 00:14:14.030 align:middle line:84%
we're essentially
telling Python to create

00:14:14.030 --> 00:14:15.800 align:middle line:90%
this resulting list of values.

00:14:15.800 --> 00:14:17.790 align:middle line:84%
That's just what a list
comprehension does.

00:14:17.790 --> 00:14:21.800 align:middle line:84%
And so this expression here
with these outer square brackets

00:14:21.800 --> 00:14:24.230 align:middle line:84%
around our entire
expression tells Python

00:14:24.230 --> 00:14:26.820 align:middle line:84%
that the resulting
thing is a list.

00:14:26.820 --> 00:14:30.260 align:middle line:90%
Yeah, this is a good question.

00:14:30.260 --> 00:14:31.270 align:middle line:90%
Other questions?

00:14:31.270 --> 00:14:35.470 align:middle line:90%


00:14:35.470 --> 00:14:37.750 align:middle line:84%
OK, so that-- oh,
yeah, question.

00:14:37.750 --> 00:14:40.180 align:middle line:84%
AUDIENCE: Does it support
multiple conditions?

00:14:40.180 --> 00:14:42.430 align:middle line:84%
ANA BELL: Does it support
multiple conditions?

00:14:42.430 --> 00:14:43.210 align:middle line:90%
Yes.

00:14:43.210 --> 00:14:47.740 align:middle line:84%
So at the end here,
you would say "if,"

00:14:47.740 --> 00:14:52.150 align:middle line:84%
and then you could wrap
them in parentheses.

00:14:52.150 --> 00:14:54.390 align:middle line:84%
I don't know if you have
to, but just to be safe,

00:14:54.390 --> 00:14:56.140 align:middle line:84%
I would wrap my
conditions in parentheses.

00:14:56.140 --> 00:14:58.708 align:middle line:84%
And you'd use "and"
or "or" or whatever

00:14:58.708 --> 00:15:01.000 align:middle line:84%
you want to combine the
expressions-- or the conditions

00:15:01.000 --> 00:15:01.642 align:middle line:90%
with.

00:15:01.642 --> 00:15:02.350 align:middle line:90%
Another question?

00:15:02.350 --> 00:15:03.227 align:middle line:90%
Yeah

00:15:03.227 --> 00:15:06.149 align:middle line:90%
AUDIENCE: [INAUDIBLE]

00:15:06.149 --> 00:15:07.123 align:middle line:90%


00:15:07.123 --> 00:15:10.770 align:middle line:90%
ANA BELL: This one, the lambda?

00:15:10.770 --> 00:15:13.110 align:middle line:84%
Here, this is a lambda
function that we

00:15:13.110 --> 00:15:16.350 align:middle line:84%
talked about I forget when,
a couple of lectures ago.

00:15:16.350 --> 00:15:18.480 align:middle line:84%
It's basically an
anonymous function.

00:15:18.480 --> 00:15:22.440 align:middle line:84%
And all it does is
return True all the time.

00:15:22.440 --> 00:15:27.560 align:middle line:84%
So the test will
always be True, which

00:15:27.560 --> 00:15:30.980 align:middle line:84%
means that when we do
if test parentheses e,

00:15:30.980 --> 00:15:33.830 align:middle line:84%
this will always be True
in this particular case.

00:15:33.830 --> 00:15:35.870 align:middle line:84%
But when given a
different lambda function,

00:15:35.870 --> 00:15:39.210 align:middle line:90%
that might not be the case.

00:15:39.210 --> 00:15:42.030 align:middle line:84%
OK, so let's move on
to the next topic.

00:15:42.030 --> 00:15:43.590 align:middle line:84%
The next, I guess,
two topics we'll

00:15:43.590 --> 00:15:44.983 align:middle line:90%
be dealing with functions.

00:15:44.983 --> 00:15:46.650 align:middle line:84%
And I want to wrap
up a couple of things

00:15:46.650 --> 00:15:50.530 align:middle line:84%
here just to give you a couple
more ideas regarding functions.

00:15:50.530 --> 00:15:52.170 align:middle line:84%
So the first one
is actually related

00:15:52.170 --> 00:15:55.870 align:middle line:84%
to this last question is the
idea of a default parameter.

00:15:55.870 --> 00:16:00.720 align:middle line:84%
So this is going to be a
way for us to add parameters

00:16:00.720 --> 00:16:03.750 align:middle line:84%
to our functions that
get some default value.

00:16:03.750 --> 00:16:06.690 align:middle line:84%
And that's what that
lambda thing actually

00:16:06.690 --> 00:16:08.130 align:middle line:90%
was in that example.

00:16:08.130 --> 00:16:09.930 align:middle line:84%
But hopefully, this
piece of the lecture

00:16:09.930 --> 00:16:11.530 align:middle line:84%
makes that a little
bit more clear.

00:16:11.530 --> 00:16:13.410 align:middle line:84%
And then the second
part regarding functions

00:16:13.410 --> 00:16:15.210 align:middle line:84%
we're going to go
over is the idea

00:16:15.210 --> 00:16:19.182 align:middle line:84%
of functions as objects,
kind of working up on that.

00:16:19.182 --> 00:16:20.640 align:middle line:84%
And we're going to
see what happens

00:16:20.640 --> 00:16:24.990 align:middle line:84%
when we return a function
object from another function.

00:16:24.990 --> 00:16:27.520 align:middle line:84%
We've seen functions as
parameters to other functions,

00:16:27.520 --> 00:16:28.980 align:middle line:84%
but we're going to
see what happens

00:16:28.980 --> 00:16:30.900 align:middle line:84%
when you make a
function be the return

00:16:30.900 --> 00:16:32.790 align:middle line:90%
value of another function.

00:16:32.790 --> 00:16:34.450 align:middle line:90%
But that's in a little bit.

00:16:34.450 --> 00:16:38.650 align:middle line:84%
For now, let's look
at default parameters.

00:16:38.650 --> 00:16:44.020 align:middle line:84%
OK, we've seen this code
before, triggering flashbacks.

00:16:44.020 --> 00:16:46.510 align:middle line:90%
So this is bisection_root.

00:16:46.510 --> 00:16:50.170 align:middle line:84%
I'll go over it just to
remind ourselves what it does.

00:16:50.170 --> 00:16:53.980 align:middle line:84%
We've got this code
inside this function

00:16:53.980 --> 00:16:56.140 align:middle line:90%
we wrote a long, long time ago.

00:16:56.140 --> 00:16:58.610 align:middle line:84%
And then we decided to
wrap it in a function

00:16:58.610 --> 00:17:01.480 align:middle line:84%
so that it's a really
nicely useful piece of code

00:17:01.480 --> 00:17:03.590 align:middle line:84%
that we can run
many, many times.

00:17:03.590 --> 00:17:05.619 align:middle line:84%
So the parameter
to this function

00:17:05.619 --> 00:17:11.170 align:middle line:84%
was x, a value we'd like to
approximate the square root of.

00:17:11.170 --> 00:17:13.810 align:middle line:84%
And the code we're
using to approximate

00:17:13.810 --> 00:17:18.250 align:middle line:84%
is using the bisection
search algorithm, which

00:17:18.250 --> 00:17:23.859 align:middle line:84%
initializes some variables,
namely epsilon, how close we

00:17:23.859 --> 00:17:27.130 align:middle line:84%
want to be to the final
answer; low and high endpoints,

00:17:27.130 --> 00:17:30.430 align:middle line:84%
we remember that; and then
an initial guess, the halfway

00:17:30.430 --> 00:17:32.230 align:middle line:90%
between low and high.

00:17:32.230 --> 00:17:37.630 align:middle line:84%
And then we keep making
guesses between low and high--

00:17:37.630 --> 00:17:40.170 align:middle line:84%
being the midpoint
of low and high,

00:17:40.170 --> 00:17:46.050 align:middle line:84%
as long as we're not close
enough to the final--

00:17:46.050 --> 00:17:48.600 align:middle line:84%
we're not close enough
to the final answer.

00:17:48.600 --> 00:17:52.080 align:middle line:84%
So we're going to either
reinitialize our low endpoint

00:17:52.080 --> 00:17:55.170 align:middle line:84%
or our high endpoint depending
on whether that guess was

00:17:55.170 --> 00:17:56.610 align:middle line:90%
too low or too high.

00:17:56.610 --> 00:17:58.680 align:middle line:84%
And then within
the loop, we make

00:17:58.680 --> 00:18:01.260 align:middle line:84%
another guess
using those changed

00:18:01.260 --> 00:18:04.620 align:middle line:84%
values of either low or
high based on if or else.

00:18:04.620 --> 00:18:07.110 align:middle line:84%
And then we keep
doing this process

00:18:07.110 --> 00:18:09.390 align:middle line:84%
of making more guesses
at the halfway point

00:18:09.390 --> 00:18:14.590 align:middle line:84%
as long as we're still
farther than epsilon away.

00:18:14.590 --> 00:18:18.190 align:middle line:84%
OK, that was a recap of
what we've done so far.

00:18:18.190 --> 00:18:21.250 align:middle line:84%
The interesting thing that we
had done with this function

00:18:21.250 --> 00:18:21.910 align:middle line:90%
was--

00:18:21.910 --> 00:18:23.710 align:middle line:84%
or when we turned
it into a function

00:18:23.710 --> 00:18:26.180 align:middle line:90%
was to return our approximation.

00:18:26.180 --> 00:18:29.860 align:middle line:84%
So this guess, instead of
just printing it to the user,

00:18:29.860 --> 00:18:32.140 align:middle line:84%
we returned it so
that it could be

00:18:32.140 --> 00:18:34.220 align:middle line:84%
useful in other
parts of the code.

00:18:34.220 --> 00:18:35.950 align:middle line:84%
And so when we
called the function,

00:18:35.950 --> 00:18:41.440 align:middle line:84%
we just said name of function
and then some value of x.

00:18:41.440 --> 00:18:46.360 align:middle line:84%
Now, there are situations
where a user would want

00:18:46.360 --> 00:18:48.480 align:middle line:90%
to change the value of epsilon.

00:18:48.480 --> 00:18:52.840 align:middle line:84%
Right now, the way we wrote this
code, epsilon is set to 0.01.

00:18:52.840 --> 00:18:54.430 align:middle line:84%
And whenever you
run the function,

00:18:54.430 --> 00:18:57.160 align:middle line:84%
it always finds
the approximation

00:18:57.160 --> 00:19:01.630 align:middle line:84%
to the square root of x
to that precision, 0.01.

00:19:01.630 --> 00:19:04.240 align:middle line:84%
Now, sometimes, depending
on the application,

00:19:04.240 --> 00:19:06.910 align:middle line:84%
the user might want an
even better approximation,

00:19:06.910 --> 00:19:11.430 align:middle line:84%
so 0.000001, or they might
not care to be as precise,

00:19:11.430 --> 00:19:15.390 align:middle line:84%
and they want maybe approximated
to 1 or to 5 or something much

00:19:15.390 --> 00:19:17.450 align:middle line:90%
bigger than 0.01.

00:19:17.450 --> 00:19:20.000 align:middle line:84%
So what are the options
in this particular case,

00:19:20.000 --> 00:19:21.860 align:middle line:90%
for these scenarios?

00:19:21.860 --> 00:19:26.370 align:middle line:84%
One option would be obviously to
go inside our function and say,

00:19:26.370 --> 00:19:29.570 align:middle line:84%
well, I'm going to change
epsilon to be something super

00:19:29.570 --> 00:19:31.850 align:middle line:90%
duper precise, 0.000001.

00:19:31.850 --> 00:19:34.400 align:middle line:84%
And so people who
call this function

00:19:34.400 --> 00:19:37.670 align:middle line:84%
will always get an
approximation to that precision.

00:19:37.670 --> 00:19:41.550 align:middle line:84%
But what about people who
don't want it that precise?

00:19:41.550 --> 00:19:43.950 align:middle line:84%
So all the function
calls are going

00:19:43.950 --> 00:19:46.150 align:middle line:84%
to be affected by
making that change,

00:19:46.150 --> 00:19:47.628 align:middle line:84%
and so that's not
really desirable.

00:19:47.628 --> 00:19:49.170 align:middle line:84%
We'd like to let
the person who makes

00:19:49.170 --> 00:19:52.860 align:middle line:84%
the function call be in charge
of what precision they'd like.

00:19:52.860 --> 00:19:56.110 align:middle line:84%
Another option is to put
epsilon outside the function,

00:19:56.110 --> 00:20:01.200 align:middle line:84%
so to say, OK, well, the only
parameter is going to be x.

00:20:01.200 --> 00:20:03.990 align:middle line:84%
And let's not set epsilon
within the function.

00:20:03.990 --> 00:20:07.630 align:middle line:84%
Let's let the user maybe set
epsilon outside the function.

00:20:07.630 --> 00:20:08.910 align:middle line:90%
And then they can use--

00:20:08.910 --> 00:20:11.160 align:middle line:84%
and then our code
will basically pop up

00:20:11.160 --> 00:20:13.950 align:middle line:84%
one level to the global
scope and use the epsilon

00:20:13.950 --> 00:20:16.170 align:middle line:90%
that the user chose.

00:20:16.170 --> 00:20:20.760 align:middle line:84%
Not a good idea because as
soon as we allow somebody using

00:20:20.760 --> 00:20:25.800 align:middle line:84%
our code to make their own
variables within our code,

00:20:25.800 --> 00:20:28.380 align:middle line:84%
we're putting our trust
in somebody else's hands.

00:20:28.380 --> 00:20:32.520 align:middle line:84%
And they might forget
to reset epsilon.

00:20:32.520 --> 00:20:35.230 align:middle line:84%
Or they might forget to
set it to begin with.

00:20:35.230 --> 00:20:37.080 align:middle line:84%
And so just using
global variables

00:20:37.080 --> 00:20:38.830 align:middle line:84%
is not a good idea
in the first place.

00:20:38.830 --> 00:20:41.430 align:middle line:84%
We'd like to keep control
of the epsilon that's

00:20:41.430 --> 00:20:44.890 align:middle line:90%
being used inside our function.

00:20:44.890 --> 00:20:47.250 align:middle line:84%
So unsurprisingly,
the last option

00:20:47.250 --> 00:20:49.050 align:middle line:90%
is going to be our best option.

00:20:49.050 --> 00:20:52.290 align:middle line:84%
Let's just add epsilon
as another parameter

00:20:52.290 --> 00:20:54.600 align:middle line:90%
to the function.

00:20:54.600 --> 00:20:56.210 align:middle line:90%
So there it is.

00:20:56.210 --> 00:21:00.830 align:middle line:84%
We've got bisection_root
again as a function.

00:21:00.830 --> 00:21:02.570 align:middle line:90%
We've got a parameter x.

00:21:02.570 --> 00:21:05.270 align:middle line:84%
And we have epsilon
as a second parameter

00:21:05.270 --> 00:21:10.770 align:middle line:84%
that the user can call
the function with.

00:21:10.770 --> 00:21:16.350 align:middle line:84%
So other than that, the function
body is exactly the same,

00:21:16.350 --> 00:21:19.260 align:middle line:84%
except that right now, when
we make a function call,

00:21:19.260 --> 00:21:23.290 align:middle line:84%
we have to pass in epsilon
as the second parameter.

00:21:23.290 --> 00:21:29.240 align:middle line:84%
So in terms of code, this
is the bisection_root

00:21:29.240 --> 00:21:30.870 align:middle line:90%
with epsilon as a parameter.

00:21:30.870 --> 00:21:36.170 align:middle line:84%
And so now the user can find
the approximation to 123 to 0.1.

00:21:36.170 --> 00:21:39.560 align:middle line:84%
It's 11.088 in case
you were wondering.

00:21:39.560 --> 00:21:44.450 align:middle line:84%
And then the approximation
to 123 to .000001,

00:21:44.450 --> 00:21:49.030 align:middle line:90%
which is 11.0905.

00:21:49.030 --> 00:21:51.640 align:middle line:84%
So, much better,
the user can now

00:21:51.640 --> 00:21:55.390 align:middle line:84%
be in charge of deciding
how close they'd

00:21:55.390 --> 00:21:59.620 align:middle line:84%
like the approximation to be
for every one of their values.

00:21:59.620 --> 00:22:04.530 align:middle line:84%
But notice that this
code is kind of verbose.

00:22:04.530 --> 00:22:08.700 align:middle line:84%
And really, most of the
time, maybe the users

00:22:08.700 --> 00:22:11.340 align:middle line:84%
don't want to be in charge
of setting the epsilon.

00:22:11.340 --> 00:22:14.970 align:middle line:84%
Maybe they don't know what
a good epsilon might be.

00:22:14.970 --> 00:22:18.180 align:middle line:84%
So how do they know that they
should choose 0.01 by default?

00:22:18.180 --> 00:22:19.710 align:middle line:84%
Maybe that's something
you could put

00:22:19.710 --> 00:22:23.560 align:middle line:84%
in the function specification
for anyone using your function.

00:22:23.560 --> 00:22:27.430 align:middle line:84%
But you're going
to rely on users

00:22:27.430 --> 00:22:31.520 align:middle line:84%
reading your specification,
and that's a little bit scary.

00:22:31.520 --> 00:22:35.200 align:middle line:84%
So instead, the functionality
that would really

00:22:35.200 --> 00:22:37.930 align:middle line:84%
like to have is
to say, OK, I want

00:22:37.930 --> 00:22:41.770 align:middle line:84%
to write a function that
does take in two parameters.

00:22:41.770 --> 00:22:45.070 align:middle line:84%
But by default, one
of those parameters

00:22:45.070 --> 00:22:47.440 align:middle line:84%
is something that I
set, as the person

00:22:47.440 --> 00:22:49.720 align:middle line:90%
who's writing this function.

00:22:49.720 --> 00:22:51.820 align:middle line:84%
So what I would
really like to have

00:22:51.820 --> 00:22:55.610 align:middle line:84%
is epsilon to have some
sort of a default value.

00:22:55.610 --> 00:22:58.380 align:middle line:84%
So if users don't know
what to call it with,

00:22:58.380 --> 00:23:01.450 align:middle line:84%
the code will just use
that default value.

00:23:01.450 --> 00:23:04.570 align:middle line:84%
And otherwise, if the
user is more experienced

00:23:04.570 --> 00:23:07.900 align:middle line:84%
and they know they'd like
an epsilon of 1 times 10

00:23:07.900 --> 00:23:10.120 align:middle line:84%
to the negative 10 or
whatever it might be,

00:23:10.120 --> 00:23:12.560 align:middle line:84%
then they can be in
charge of setting it.

00:23:12.560 --> 00:23:14.680 align:middle line:84%
So most of the time,
we want to call

00:23:14.680 --> 00:23:17.950 align:middle line:84%
the bisection_root function
without an epsilon parameter

00:23:17.950 --> 00:23:19.900 align:middle line:84%
so that it may
use a default one.

00:23:19.900 --> 00:23:22.330 align:middle line:84%
But sometimes we'd
like to allow the user

00:23:22.330 --> 00:23:25.050 align:middle line:90%
to actually set the epsilon.

00:23:25.050 --> 00:23:27.150 align:middle line:84%
And so to that end,
we're introducing

00:23:27.150 --> 00:23:29.730 align:middle line:84%
the idea of keyword
parameters, also known

00:23:29.730 --> 00:23:31.230 align:middle line:90%
as default parameters.

00:23:31.230 --> 00:23:35.530 align:middle line:90%
And they are set like this.

00:23:35.530 --> 00:23:37.800 align:middle line:84%
So the bisection_root
function definition

00:23:37.800 --> 00:23:39.390 align:middle line:84%
still takes in the
thing we'd like

00:23:39.390 --> 00:23:41.940 align:middle line:84%
to approximate the
square root of, x.

00:23:41.940 --> 00:23:45.330 align:middle line:84%
But the second
parameter here, epsilon,

00:23:45.330 --> 00:23:48.970 align:middle line:84%
will be equal to something
inside the function definition.

00:23:48.970 --> 00:23:50.580 align:middle line:84%
So we as the people
who are writing

00:23:50.580 --> 00:23:53.760 align:middle line:84%
this function are going to say
the default value of epsilon

00:23:53.760 --> 00:23:58.660 align:middle line:90%
is 0.01.

00:23:58.660 --> 00:24:02.740 align:middle line:84%
So that means when we call
the function down here,

00:24:02.740 --> 00:24:06.550 align:middle line:84%
if the user makes a function
call without explicitly passing

00:24:06.550 --> 00:24:10.600 align:middle line:84%
in a second parameter, Python
will use the default one

00:24:10.600 --> 00:24:12.820 align:middle line:84%
that the person who
wrote the function set.

00:24:12.820 --> 00:24:16.240 align:middle line:84%
So Python will run
bisection_root of 123

00:24:16.240 --> 00:24:19.450 align:middle line:90%
with epsilon being 0.01.

00:24:19.450 --> 00:24:23.020 align:middle line:84%
And otherwise, if the user does
want to override that epsilon,

00:24:23.020 --> 00:24:24.640 align:middle line:84%
they can just pass
it in themselves,

00:24:24.640 --> 00:24:30.920 align:middle line:84%
and that default value of 0.01
will be overridden to be 0.5.

00:24:30.920 --> 00:24:36.790 align:middle line:84%
And so in our code here,
this is the bisection_root

00:24:36.790 --> 00:24:38.090 align:middle line:90%
with the default values.

00:24:38.090 --> 00:24:40.930 align:middle line:84%
And so you can see here
if I run it with 123,

00:24:40.930 --> 00:24:42.970 align:middle line:84%
even though there are
two parameters here

00:24:42.970 --> 00:24:45.850 align:middle line:84%
for the bisection
square root function,

00:24:45.850 --> 00:24:49.450 align:middle line:84%
Python doesn't complain because
it's using epsilon as 0.01.

00:24:49.450 --> 00:24:53.410 align:middle line:84%
So I run it, and
it runs just fine.

00:24:53.410 --> 00:24:55.890 align:middle line:84%
But in the second line
here, if I actually

00:24:55.890 --> 00:24:57.870 align:middle line:90%
want to use 0.5 as my default--

00:24:57.870 --> 00:25:01.470 align:middle line:84%
as my epsilon value, it
overrides my default parameter,

00:25:01.470 --> 00:25:03.840 align:middle line:84%
and it calculates the
square root of 123

00:25:03.840 --> 00:25:09.560 align:middle line:90%
with epsilon being 0.5.

00:25:09.560 --> 00:25:10.475 align:middle line:90%
Questions so far?

00:25:10.475 --> 00:25:14.730 align:middle line:90%


00:25:14.730 --> 00:25:17.420 align:middle line:84%
So now that we've introduced
default parameters,

00:25:17.420 --> 00:25:22.190 align:middle line:84%
there's a few rules about
making function calls.

00:25:22.190 --> 00:25:25.305 align:middle line:84%
When you create the function
definition, so over here,

00:25:25.305 --> 00:25:26.930 align:middle line:84%
when you're the one
defining a function

00:25:26.930 --> 00:25:28.760 align:middle line:84%
and you decide to
allow some default

00:25:28.760 --> 00:25:30.920 align:middle line:84%
parameters in your
parameter list,

00:25:30.920 --> 00:25:32.840 align:middle line:84%
everything that's
a default parameter

00:25:32.840 --> 00:25:34.400 align:middle line:90%
needs to go at the end.

00:25:34.400 --> 00:25:36.170 align:middle line:90%
You can't switch these around.

00:25:36.170 --> 00:25:39.830 align:middle line:84%
You can't say epsilon
equals 0.01 comma x.

00:25:39.830 --> 00:25:42.170 align:middle line:90%
Python will not allow that.

00:25:42.170 --> 00:25:44.470 align:middle line:84%
So any time you have
default parameters,

00:25:44.470 --> 00:25:48.150 align:middle line:84%
they always have
to go to the end.

00:25:48.150 --> 00:25:50.490 align:middle line:84%
That's the only rule for
making the function call

00:25:50.490 --> 00:25:52.470 align:middle line:84%
or making-- defining the
function with default

00:25:52.470 --> 00:25:53.280 align:middle line:90%
parameters.

00:25:53.280 --> 00:25:55.930 align:middle line:84%
And then once you have
default parameters,

00:25:55.930 --> 00:25:57.720 align:middle line:84%
you can actually
call the function

00:25:57.720 --> 00:26:00.310 align:middle line:84%
in many, many, many
different ways.

00:26:00.310 --> 00:26:02.177 align:middle line:84%
And I know some of
these will be confusing.

00:26:02.177 --> 00:26:04.260 align:middle line:84%
You might not know whether
they're allowed or not.

00:26:04.260 --> 00:26:06.810 align:middle line:84%
You can never go wrong
with the last one,

00:26:06.810 --> 00:26:08.900 align:middle line:84%
as we're going to
see you in a bit.

00:26:08.900 --> 00:26:11.530 align:middle line:84%
So the first one
here showcases what

00:26:11.530 --> 00:26:14.890 align:middle line:84%
happens when you give values for
everything that's not a default

00:26:14.890 --> 00:26:17.850 align:middle line:90%
parameter, in this case just x.

00:26:17.850 --> 00:26:20.970 align:middle line:84%
If you just give a value
for nondefault parameters,

00:26:20.970 --> 00:26:23.470 align:middle line:84%
Python sets default parameters
for everything else.

00:26:23.470 --> 00:26:26.310 align:middle line:90%
So not a big deal.

00:26:26.310 --> 00:26:28.440 align:middle line:84%
Alternatively, you
can pass in, just

00:26:28.440 --> 00:26:31.103 align:middle line:84%
like we have in the past when
we write our own functions

00:26:31.103 --> 00:26:32.520 align:middle line:84%
with multiple
parameters-- you can

00:26:32.520 --> 00:26:35.280 align:middle line:84%
pass in one at a time
in the same order

00:26:35.280 --> 00:26:38.970 align:middle line:84%
values for every one of those
parameters, default or not.

00:26:38.970 --> 00:26:40.748 align:middle line:84%
And if you pass in
values for all of them,

00:26:40.748 --> 00:26:42.540 align:middle line:84%
Python will not be
confused, and it'll just

00:26:42.540 --> 00:26:45.700 align:middle line:90%
match them one at a time.

00:26:45.700 --> 00:26:48.100 align:middle line:84%
Variations on that,
you can always

00:26:48.100 --> 00:26:53.570 align:middle line:84%
pass in a value for
a parameter name.

00:26:53.570 --> 00:26:56.120 align:middle line:84%
So looking at the
function definition,

00:26:56.120 --> 00:26:59.740 align:middle line:84%
we can see the parameter
names, the formal parameters

00:26:59.740 --> 00:27:02.570 align:middle line:90%
are named x and epsilon.

00:27:02.570 --> 00:27:04.760 align:middle line:84%
So when you make
your function calls,

00:27:04.760 --> 00:27:08.620 align:middle line:84%
you can actually explicitly
tell Python something like this,

00:27:08.620 --> 00:27:12.400 align:middle line:84%
x equals 123,
epsilon equals 0.1.

00:27:12.400 --> 00:27:13.900 align:middle line:84%
And if you have
more parameters, you

00:27:13.900 --> 00:27:16.180 align:middle line:84%
say that parameter
equals whatever value you

00:27:16.180 --> 00:27:17.800 align:middle line:90%
want to run it with.

00:27:17.800 --> 00:27:19.920 align:middle line:84%
And so that will
not confuse Python.

00:27:19.920 --> 00:27:21.420 align:middle line:84%
And if you do it
in that way, you

00:27:21.420 --> 00:27:24.360 align:middle line:84%
can actually do it
in any order you'd

00:27:24.360 --> 00:27:26.580 align:middle line:84%
like because Python
will just assign

00:27:26.580 --> 00:27:30.330 align:middle line:84%
each one of these variables to
be whatever you told them to.

00:27:30.330 --> 00:27:33.330 align:middle line:84%
So worst case, you
just do something

00:27:33.330 --> 00:27:35.972 align:middle line:84%
like this, where one
at a time you just say

00:27:35.972 --> 00:27:38.430 align:middle line:84%
what the formal parameter is
and its value, and then Python

00:27:38.430 --> 00:27:40.560 align:middle line:90%
will not get confused.

00:27:40.560 --> 00:27:43.930 align:middle line:84%
The ones at the bottom, though,
is where we run into trouble.

00:27:43.930 --> 00:27:48.360 align:middle line:84%
So for example, if you put
the default parameter first

00:27:48.360 --> 00:27:50.550 align:middle line:84%
and then you put an
actual parameter-- sorry,

00:27:50.550 --> 00:27:52.830 align:middle line:84%
you put the default
parameter first and then

00:27:52.830 --> 00:27:55.500 align:middle line:84%
any parameter that's not
a default one afterward,

00:27:55.500 --> 00:27:59.250 align:middle line:84%
Python gives an error
because the default ones

00:27:59.250 --> 00:28:02.340 align:middle line:84%
have to go after
the nondefault ones.

00:28:02.340 --> 00:28:05.100 align:middle line:84%
And the last one doesn't
actually give an error,

00:28:05.100 --> 00:28:08.800 align:middle line:84%
but Python, remember, matches
parameters one by one.

00:28:08.800 --> 00:28:11.790 align:middle line:84%
So it's actually going
to find an approximation

00:28:11.790 --> 00:28:18.550 align:middle line:84%
to the square root of
0.001 to an epsilon of 123

00:28:18.550 --> 00:28:20.990 align:middle line:84%
because it's just mapping
the parameters one at a time.

00:28:20.990 --> 00:28:23.710 align:middle line:84%
And so that's not an
error, but it's not

00:28:23.710 --> 00:28:27.180 align:middle line:90%
exactly what we want it to do.

00:28:27.180 --> 00:28:28.355 align:middle line:90%
Questions about this?

00:28:28.355 --> 00:28:32.230 align:middle line:90%


00:28:32.230 --> 00:28:35.020 align:middle line:90%
OK.

00:28:35.020 --> 00:28:38.380 align:middle line:84%
So now let's move
on to another thing,

00:28:38.380 --> 00:28:43.010 align:middle line:84%
another sort of nuance
about functions.

00:28:43.010 --> 00:28:45.830 align:middle line:84%
And we're going to go back
to the idea of functions

00:28:45.830 --> 00:28:48.570 align:middle line:90%
being objects in Python.

00:28:48.570 --> 00:28:53.910 align:middle line:84%
So I drew this picture back when
we first learned of objects--

00:28:53.910 --> 00:28:55.930 align:middle line:90%
of functions as objects.

00:28:55.930 --> 00:28:58.510 align:middle line:84%
So I'll just do it again
just to jog your memory.

00:28:58.510 --> 00:29:00.750 align:middle line:84%
So remember that when
we make a function

00:29:00.750 --> 00:29:08.680 align:middle line:84%
definition, inside the memory
Python creates an object.

00:29:08.680 --> 00:29:11.770 align:middle line:84%
As soon as we see just
this function definition,

00:29:11.770 --> 00:29:14.650 align:middle line:84%
Python doesn't care what
code is inside here.

00:29:14.650 --> 00:29:16.540 align:middle line:90%
This code does not run.

00:29:16.540 --> 00:29:18.040 align:middle line:84%
It only runs when
it's being called.

00:29:18.040 --> 00:29:21.660 align:middle line:84%
And right here, I have not
made a function call at all.

00:29:21.660 --> 00:29:24.190 align:middle line:84%
All Python knows
at this point is

00:29:24.190 --> 00:29:29.050 align:middle line:84%
that there is a function object
inside memory, and its name--

00:29:29.050 --> 00:29:32.480 align:middle line:90%
its name is is_even.

00:29:32.480 --> 00:29:35.930 align:middle line:84%
And this is exactly the
same as creating an integer

00:29:35.930 --> 00:29:38.060 align:middle line:84%
object inside memory
and giving it the name

00:29:38.060 --> 00:29:41.030 align:middle line:84%
r through a line
like this or creating

00:29:41.030 --> 00:29:43.790 align:middle line:84%
a float object in memory
and giving it the name pi.

00:29:43.790 --> 00:29:47.560 align:middle line:84%
It's just some object
with some name.

00:29:47.560 --> 00:29:51.270 align:middle line:84%
And so that means that we
can have some code that

00:29:51.270 --> 00:29:55.290 align:middle line:84%
looks like this, which is
going to essentially create

00:29:55.290 --> 00:29:59.590 align:middle line:84%
an alias for that
function object in memory.

00:29:59.590 --> 00:30:06.120 align:middle line:84%
So here, the name is_even
refers to that function object.

00:30:06.120 --> 00:30:07.890 align:middle line:84%
And I'm telling
Python that I would

00:30:07.890 --> 00:30:11.880 align:middle line:84%
like to refer to that function
object using the name myfunc as

00:30:11.880 --> 00:30:12.640 align:middle line:90%
well.

00:30:12.640 --> 00:30:16.140 align:middle line:84%
So both myfunc and
is_even are names that

00:30:16.140 --> 00:30:19.020 align:middle line:90%
point to this object in memory.

00:30:19.020 --> 00:30:22.140 align:middle line:90%
It's not a function call.

00:30:22.140 --> 00:30:24.420 align:middle line:84%
I'm not trying to figure
out if some number is even.

00:30:24.420 --> 00:30:29.130 align:middle line:84%
I am literally giving another
name to this function,

00:30:29.130 --> 00:30:31.590 align:middle line:84%
this code that does
this thing here.

00:30:31.590 --> 00:30:34.140 align:middle line:90%


00:30:34.140 --> 00:30:36.740 align:middle line:84%
And so that means that
if I have two names that

00:30:36.740 --> 00:30:41.880 align:middle line:84%
point to the same object, if
I am going to invoke those two

00:30:41.880 --> 00:30:45.690 align:middle line:84%
names, as I do here,
with some parameters,

00:30:45.690 --> 00:30:47.700 align:middle line:84%
Python is going
to say, well, I'm

00:30:47.700 --> 00:30:50.520 align:middle line:84%
going to run the code
pointed to by these names

00:30:50.520 --> 00:30:51.940 align:middle line:90%
with these parameters.

00:30:51.940 --> 00:30:56.860 align:middle line:84%
So they will both run the
code that they're pointing to.

00:30:56.860 --> 00:31:00.130 align:middle line:84%
This is even, and so it's just
going to return True or False.

00:31:00.130 --> 00:31:03.630 align:middle line:90%
We've seen this before.

00:31:03.630 --> 00:31:08.480 align:middle line:84%
So remember, just another name
for that object in memory.

00:31:08.480 --> 00:31:12.730 align:middle line:84%
So we've seen already how we
can pass functions as parameters

00:31:12.730 --> 00:31:14.360 align:middle line:90%
to other functions.

00:31:14.360 --> 00:31:16.720 align:middle line:84%
And now we're going
to see what happens

00:31:16.720 --> 00:31:21.500 align:middle line:84%
when we return a function
from another function.

00:31:21.500 --> 00:31:25.210 align:middle line:84%
So we're not returning
a function call here.

00:31:25.210 --> 00:31:28.840 align:middle line:84%
We are returning
a function object.

00:31:28.840 --> 00:31:32.730 align:middle line:84%
So in this particular code,
we have only one function.

00:31:32.730 --> 00:31:36.940 align:middle line:84%
It's named make_prod,
and it happens

00:31:36.940 --> 00:31:39.190 align:middle line:84%
to have some stuff
going on inside it.

00:31:39.190 --> 00:31:41.500 align:middle line:84%
So what's the stuff that
this function will do?

00:31:41.500 --> 00:31:45.470 align:middle line:84%
Well, this function itself
will create another function.

00:31:45.470 --> 00:31:51.300 align:middle line:84%
So this g only exists
whenever make_prod exists.

00:31:51.300 --> 00:31:55.070 align:middle line:84%
The main program,
you can think of it

00:31:55.070 --> 00:31:57.620 align:middle line:84%
as this level of
the code in terms

00:31:57.620 --> 00:32:02.570 align:middle line:84%
of indentation-- the main
program does not know about g.

00:32:02.570 --> 00:32:05.600 align:middle line:84%
G is only defined
inside make_prod.

00:32:05.600 --> 00:32:07.460 align:middle line:84%
So when we first run
this program as is,

00:32:07.460 --> 00:32:09.090 align:middle line:84%
there's no function
call being done.

00:32:09.090 --> 00:32:11.240 align:middle line:84%
So the main program
does not know anything

00:32:11.240 --> 00:32:14.780 align:middle line:84%
about the internals
of make_prod.

00:32:14.780 --> 00:32:17.900 align:middle line:84%
So make_prod creates
its own function here.

00:32:17.900 --> 00:32:22.250 align:middle line:84%
And then all it does is
return this function object.

00:32:22.250 --> 00:32:23.930 align:middle line:90%
Notice it's not a function call.

00:32:23.930 --> 00:32:25.340 align:middle line:84%
There's no open
close parentheses

00:32:25.340 --> 00:32:26.660 align:middle line:90%
with a parameter in it.

00:32:26.660 --> 00:32:28.880 align:middle line:90%
It's just the name g.

00:32:28.880 --> 00:32:32.090 align:middle line:90%
It's this function object.

00:32:32.090 --> 00:32:33.930 align:middle line:90%
That's the key thing here.

00:32:33.930 --> 00:32:39.170 align:middle line:84%
So let's run two codes,
this one and this one.

00:32:39.170 --> 00:32:42.520 align:middle line:84%
They will do the
exact same thing.

00:32:42.520 --> 00:32:47.570 align:middle line:84%
They're going to call
make_prod with some parameters.

00:32:47.570 --> 00:32:51.550 align:middle line:84%
And then we're going to see what
happens when we return this g.

00:32:51.550 --> 00:32:54.460 align:middle line:84%
And notice already it's looking
slightly different than what

00:32:54.460 --> 00:32:55.750 align:middle line:90%
we've been doing before.

00:32:55.750 --> 00:32:58.570 align:middle line:84%
Yes, we have a call
to make_prod here,

00:32:58.570 --> 00:33:02.710 align:middle line:84%
but we've kind of chained
another function call

00:33:02.710 --> 00:33:05.020 align:middle line:90%
right after make_prod.

00:33:05.020 --> 00:33:07.930 align:middle line:84%
We've got make_prod
parentheses 2, parentheses 3.

00:33:07.930 --> 00:33:09.850 align:middle line:90%
And so this is kind of like--

00:33:09.850 --> 00:33:12.140 align:middle line:84%
I think of it as chaining
a bunch of function calls

00:33:12.140 --> 00:33:12.640 align:middle line:90%
together.

00:33:12.640 --> 00:33:14.320 align:middle line:84%
And this is possible,
as we're going

00:33:14.320 --> 00:33:18.550 align:middle line:84%
to see when we step through
the function environments that

00:33:18.550 --> 00:33:20.530 align:middle line:84%
are being created--
this is made possible

00:33:20.530 --> 00:33:23.440 align:middle line:84%
because make_prod,
this function call,

00:33:23.440 --> 00:33:25.645 align:middle line:90%
returns a function itself.

00:33:25.645 --> 00:33:28.690 align:middle line:90%


00:33:28.690 --> 00:33:32.970 align:middle line:84%
So let's step through the code
on the left very carefully.

00:33:32.970 --> 00:33:35.280 align:middle line:84%
And then I'll step through
the code on the right, which

00:33:35.280 --> 00:33:37.110 align:middle line:90%
will do the exact same thing.

00:33:37.110 --> 00:33:42.230 align:middle line:84%
And hopefully it will clear up
confusions if we do it twice.

00:33:42.230 --> 00:33:44.350 align:middle line:84%
So this is the
code from the left.

00:33:44.350 --> 00:33:48.640 align:middle line:84%
Let's say we have this
exact program here.

00:33:48.640 --> 00:33:50.920 align:middle line:84%
I've got one
function definition.

00:33:50.920 --> 00:33:53.440 align:middle line:84%
And then I've got one
function call here.

00:33:53.440 --> 00:33:56.050 align:middle line:84%
And then I'm going to
print the return value.

00:33:56.050 --> 00:33:58.950 align:middle line:84%
So as soon as I
run my code, Python

00:33:58.950 --> 00:34:01.020 align:middle line:90%
creates my global environment.

00:34:01.020 --> 00:34:02.640 align:middle line:84%
And in the global
environment, this

00:34:02.640 --> 00:34:06.630 align:middle line:84%
is the scope of
the main program.

00:34:06.630 --> 00:34:07.720 align:middle line:90%
What do we have?

00:34:07.720 --> 00:34:10.210 align:middle line:84%
Well, we have one
function definition

00:34:10.210 --> 00:34:12.168 align:middle line:90%
which has some code within it.

00:34:12.168 --> 00:34:13.710 align:middle line:84%
I don't care what
it is at this point

00:34:13.710 --> 00:34:16.440 align:middle line:84%
because I don't have
a function call.

00:34:16.440 --> 00:34:20.030 align:middle line:84%
So then the next thing
that I need to do

00:34:20.030 --> 00:34:23.389 align:middle line:84%
is go down here and
say val equals--

00:34:23.389 --> 00:34:25.100 align:middle line:84%
so I'm going to
create a variable val

00:34:25.100 --> 00:34:27.199 align:middle line:90%
in my global environment.

00:34:27.199 --> 00:34:30.000 align:middle line:84%
And I'm going to
make a function call.

00:34:30.000 --> 00:34:32.810 align:middle line:84%
So function calls are
done left to right, just

00:34:32.810 --> 00:34:34.280 align:middle line:90%
like expressions.

00:34:34.280 --> 00:34:37.550 align:middle line:84%
And the first thing Python
sees is this function call,

00:34:37.550 --> 00:34:41.190 align:middle line:90%
make_prod parentheses 2.

00:34:41.190 --> 00:34:45.239 align:middle line:84%
It's a function call, so we need
to create another orange box

00:34:45.239 --> 00:34:48.690 align:middle line:84%
because a new environment
gets created every time we

00:34:48.690 --> 00:34:51.429 align:middle line:90%
make a function call.

00:34:51.429 --> 00:34:56.370 align:middle line:84%
So here I have my scope, my
environment for make_prod.

00:34:56.370 --> 00:34:58.980 align:middle line:84%
And I'm currently
just stuck here,

00:34:58.980 --> 00:35:01.560 align:middle line:84%
trying to figure out what
this is going to return, just

00:35:01.560 --> 00:35:03.240 align:middle line:90%
the red box here.

00:35:03.240 --> 00:35:05.340 align:middle line:84%
Well, every time I
have a function call,

00:35:05.340 --> 00:35:07.290 align:middle line:84%
I need to look at the
function definition.

00:35:07.290 --> 00:35:09.960 align:middle line:84%
And the function definition
says, well, there's

00:35:09.960 --> 00:35:12.420 align:middle line:84%
one formal parameter
"a" that I need

00:35:12.420 --> 00:35:14.820 align:middle line:90%
to map to the actual parameter.

00:35:14.820 --> 00:35:18.206 align:middle line:84%
So the thing I'm calling
make_prod with is 2.

00:35:18.206 --> 00:35:20.900 align:middle line:84%
That should be pretty
straightforward, right?

00:35:20.900 --> 00:35:27.360 align:middle line:84%
And then I can move on to
do the body of make_prod.

00:35:27.360 --> 00:35:31.630 align:middle line:84%
OK, so the body
of make_prod says,

00:35:31.630 --> 00:35:33.930 align:middle line:84%
I would like to create
a function definition.

00:35:33.930 --> 00:35:36.150 align:middle line:90%
The name of this function is g.

00:35:36.150 --> 00:35:37.710 align:middle line:90%
So there is g.

00:35:37.710 --> 00:35:39.600 align:middle line:90%
And it contains some code.

00:35:39.600 --> 00:35:42.390 align:middle line:84%
Again, I don't care what this
code is because I'm not making

00:35:42.390 --> 00:35:44.370 align:middle line:90%
a function call to g yet.

00:35:44.370 --> 00:35:46.216 align:middle line:90%
Right now, I'm just defining g.

00:35:46.216 --> 00:35:49.510 align:middle line:90%


00:35:49.510 --> 00:35:50.800 align:middle line:90%
So far, so good.

00:35:50.800 --> 00:35:57.910 align:middle line:84%
So this g, I want you to notice,
only exists inside this call

00:35:57.910 --> 00:36:00.260 align:middle line:90%
to make_prod.

00:36:00.260 --> 00:36:06.200 align:middle line:84%
The global environment does
not know about g at this point

00:36:06.200 --> 00:36:10.340 align:middle line:84%
because we only define
g inside make_prod.

00:36:10.340 --> 00:36:11.540 align:middle line:90%
It's here, right?

00:36:11.540 --> 00:36:13.820 align:middle line:84%
I didn't define it
outside of make_prod,

00:36:13.820 --> 00:36:15.920 align:middle line:84%
so the global scope
doesn't know about it.

00:36:15.920 --> 00:36:19.460 align:middle line:84%
But make_prod does
know about it.

00:36:19.460 --> 00:36:22.780 align:middle line:84%
And so the only way that
the global environment

00:36:22.780 --> 00:36:28.240 align:middle line:84%
can know about g is if this
make_prod function somehow

00:36:28.240 --> 00:36:29.686 align:middle line:90%
returns g.

00:36:29.686 --> 00:36:33.090 align:middle line:90%


00:36:33.090 --> 00:36:37.140 align:middle line:84%
So if we pass g back as
a parameter-- as a value,

00:36:37.140 --> 00:36:39.450 align:middle line:84%
sorry, to the main
program scope,

00:36:39.450 --> 00:36:41.550 align:middle line:84%
the main program
can know about g.

00:36:41.550 --> 00:36:44.040 align:middle line:84%
But otherwise, g
is kind of stuck

00:36:44.040 --> 00:36:48.030 align:middle line:84%
in this little subtask, little
environment of make_prod.

00:36:48.030 --> 00:36:51.370 align:middle line:84%
And the main program
doesn't know about it.

00:36:51.370 --> 00:36:53.880 align:middle line:84%
And so that's what
this code is doing.

00:36:53.880 --> 00:36:56.730 align:middle line:84%
It's essentially saying,
well, I've made my definition,

00:36:56.730 --> 00:36:58.650 align:middle line:90%
and now I return g.

00:36:58.650 --> 00:37:04.620 align:middle line:84%
So here, this g and its code--
and the associated code,

00:37:04.620 --> 00:37:09.500 align:middle line:84%
so this object
pointed to by g, is

00:37:09.500 --> 00:37:13.230 align:middle line:84%
going to be returned
back to the main program.

00:37:13.230 --> 00:37:18.270 align:middle line:84%
So now the main program knows
about this object g that has

00:37:18.270 --> 00:37:21.760 align:middle line:84%
some code associated with it,
this line here where it returns

00:37:21.760 --> 00:37:22.260 align:middle line:90%
a*b.

00:37:22.260 --> 00:37:25.400 align:middle line:90%


00:37:25.400 --> 00:37:29.390 align:middle line:84%
So the thing that I've
boxed in red down here

00:37:29.390 --> 00:37:33.510 align:middle line:84%
is the return value
from make_prod 2.

00:37:33.510 --> 00:37:36.300 align:middle line:90%
And make_prod 2 returned g.

00:37:36.300 --> 00:37:40.020 align:middle line:84%
So this, you can
essentially say, is g.

00:37:40.020 --> 00:37:43.770 align:middle line:90%


00:37:43.770 --> 00:37:44.970 align:middle line:90%
Is that OK?

00:37:44.970 --> 00:37:46.790 align:middle line:90%
Does that make sense?

00:37:46.790 --> 00:37:49.280 align:middle line:84%
We're passing functions
along, not function calls.

00:37:49.280 --> 00:37:53.240 align:middle line:84%
And so this is just
a function named g.

00:37:53.240 --> 00:37:56.000 align:middle line:84%
And so now, this
line of code, val

00:37:56.000 --> 00:37:59.690 align:middle line:84%
equals, if we replace
the red box with g,

00:37:59.690 --> 00:38:02.990 align:middle line:90%
val equals g parentheses 3.

00:38:02.990 --> 00:38:06.900 align:middle line:90%


00:38:06.900 --> 00:38:10.980 align:middle line:84%
So g parentheses 3 is
another function call, right?

00:38:10.980 --> 00:38:13.680 align:middle line:84%
Just clearly, we look at
it, it's a function call.

00:38:13.680 --> 00:38:17.440 align:middle line:84%
It's got a function name,
parentheses, and a parameter.

00:38:17.440 --> 00:38:19.230 align:middle line:84%
And so since it's
a function call,

00:38:19.230 --> 00:38:23.530 align:middle line:84%
we create another scope
for this function call.

00:38:23.530 --> 00:38:27.040 align:middle line:84%
As before, we look at what
g takes in as a parameter.

00:38:27.040 --> 00:38:31.060 align:middle line:84%
It's a variable named
b, a formal parameter b.

00:38:31.060 --> 00:38:35.480 align:middle line:84%
And we map it to 3 because
that's our function

00:38:35.480 --> 00:38:38.870 align:middle line:90%
call, g parentheses 3.

00:38:38.870 --> 00:38:43.340 align:middle line:84%
And then we have to
do the body of g.

00:38:43.340 --> 00:38:46.250 align:middle line:84%
The body of g says return
"a" multiplied by b.

00:38:46.250 --> 00:38:48.200 align:middle line:90%
Well, I know what b is.

00:38:48.200 --> 00:38:51.350 align:middle line:84%
It's 3 because you just
called me with that value.

00:38:51.350 --> 00:38:52.910 align:middle line:90%
But what is "a"?

00:38:52.910 --> 00:38:56.320 align:middle line:84%
The scope of g has
no "a" within it.

00:38:56.320 --> 00:38:59.520 align:middle line:84%
So thinking back to our
function, our lecture

00:38:59.520 --> 00:39:02.550 align:middle line:84%
on functions, if a
function call doesn't

00:39:02.550 --> 00:39:05.310 align:middle line:84%
know about a variable name
within its environment,

00:39:05.310 --> 00:39:10.620 align:middle line:84%
within its scope, it moves up
the function call hierarchy.

00:39:10.620 --> 00:39:13.530 align:middle line:90%
So it says, who called me?

00:39:13.530 --> 00:39:15.840 align:middle line:90%
Where was g defined?

00:39:15.840 --> 00:39:18.990 align:middle line:84%
Well, g was defined
inside make_prod.

00:39:18.990 --> 00:39:21.810 align:middle line:84%
And so it was called
from make_prod.

00:39:21.810 --> 00:39:25.380 align:middle line:84%
Does make_prod have
a variable named "a"?

00:39:25.380 --> 00:39:26.400 align:middle line:90%
It does, right?

00:39:26.400 --> 00:39:28.140 align:middle line:90%
And its value was 2.

00:39:28.140 --> 00:39:31.050 align:middle line:84%
So we didn't need to go any
further up the hierarchy.

00:39:31.050 --> 00:39:33.150 align:middle line:84%
We've already found
a variable named "a,"

00:39:33.150 --> 00:39:37.910 align:middle line:84%
so Python will use b
is 3 and "a" is two.

00:39:37.910 --> 00:39:39.950 align:middle line:90%
Multiplies that to be 6.

00:39:39.950 --> 00:39:45.730 align:middle line:84%
And then the g function
call can return 6.

00:39:45.730 --> 00:39:47.890 align:middle line:84%
It returns it back
to the main program

00:39:47.890 --> 00:39:50.570 align:middle line:84%
because that's where this
function call was being done.

00:39:50.570 --> 00:39:53.920 align:middle line:84%
Remember we had this
replaced with g parentheses 3

00:39:53.920 --> 00:39:56.600 align:middle line:90%
out in this global scope here.

00:39:56.600 --> 00:40:00.340 align:middle line:84%
And so that 6 gets returned
back to the main program.

00:40:00.340 --> 00:40:03.220 align:middle line:90%
And then val becomes 6.

00:40:03.220 --> 00:40:04.090 align:middle line:90%
And we print 6.

00:40:04.090 --> 00:40:07.900 align:middle line:90%


00:40:07.900 --> 00:40:12.670 align:middle line:84%
OK, so that was showing you
how to chain function calls

00:40:12.670 --> 00:40:13.330 align:middle line:90%
together.

00:40:13.330 --> 00:40:17.320 align:middle line:84%
And this was only made
possible because make_prod

00:40:17.320 --> 00:40:20.740 align:middle line:84%
as a function returned
another function object.

00:40:20.740 --> 00:40:23.440 align:middle line:84%
If make_prod returned,
I don't know,

00:40:23.440 --> 00:40:26.740 align:middle line:84%
a tuple or an integer or
something that was not

00:40:26.740 --> 00:40:30.220 align:middle line:84%
a function, this code would
fail because the return

00:40:30.220 --> 00:40:34.180 align:middle line:84%
from make_prod would be-- let's
say it returned the number 10.

00:40:34.180 --> 00:40:37.360 align:middle line:84%
The return from make_prod
would be replaced with 10,

00:40:37.360 --> 00:40:39.070 align:middle line:84%
and then Python
would see this line

00:40:39.070 --> 00:40:43.520 align:middle line:84%
as 10 parentheses 3, and
what the heck is that?

00:40:43.520 --> 00:40:45.540 align:middle line:90%
And so it would completely fail.

00:40:45.540 --> 00:40:47.600 align:middle line:84%
And so this is only made
possible by the fact

00:40:47.600 --> 00:40:51.480 align:middle line:84%
that this make_prod function
returns a function object.

00:40:51.480 --> 00:40:53.945 align:middle line:84%
And so we're able to chain
these function calls together.

00:40:53.945 --> 00:40:56.990 align:middle line:90%


00:40:56.990 --> 00:40:59.560 align:middle line:84%
So let's look at
the exact same code,

00:40:59.560 --> 00:41:02.660 align:middle line:84%
except this time instead
of chaining them in a row,

00:41:02.660 --> 00:41:08.540 align:middle line:84%
let's explicitly save
the intermediate steps.

00:41:08.540 --> 00:41:11.890 align:middle line:84%
So what I'm going to do is
say make_prod parentheses

00:41:11.890 --> 00:41:15.030 align:middle line:84%
2 I'm going to
save as a variable

00:41:15.030 --> 00:41:22.250 align:middle line:84%
and then make that variable
call the 3, the second part

00:41:22.250 --> 00:41:25.090 align:middle line:84%
of my chain from
the previous slide.

00:41:25.090 --> 00:41:27.730 align:middle line:84%
And it's going to do
the exact same thing.

00:41:27.730 --> 00:41:32.710 align:middle line:84%
So here I've got the global
scope just like before.

00:41:32.710 --> 00:41:35.040 align:middle line:84%
I've got a function
definition for make_prod.

00:41:35.040 --> 00:41:36.360 align:middle line:90%
So this is the name make_prod.

00:41:36.360 --> 00:41:38.850 align:middle line:90%
It points to some code.

00:41:38.850 --> 00:41:41.280 align:middle line:84%
And then I've got this
variable doubler that's

00:41:41.280 --> 00:41:43.390 align:middle line:90%
going to equal something.

00:41:43.390 --> 00:41:46.030 align:middle line:90%
So it's a function call.

00:41:46.030 --> 00:41:49.750 align:middle line:84%
The function call says here's
my environment for make_prod

00:41:49.750 --> 00:41:51.020 align:middle line:90%
with its scope.

00:41:51.020 --> 00:41:53.350 align:middle line:84%
So in this particular
scope, I've

00:41:53.350 --> 00:41:57.530 align:middle line:84%
got my formal parameter
"a" that maps to 2.

00:41:57.530 --> 00:42:01.850 align:middle line:84%
And then the function body
itself creates this variable g.

00:42:01.850 --> 00:42:04.745 align:middle line:84%
That's just some code,
exactly the same as before.

00:42:04.745 --> 00:42:08.460 align:middle line:90%


00:42:08.460 --> 00:42:10.590 align:middle line:84%
Any questions so
far based on what

00:42:10.590 --> 00:42:13.770 align:middle line:84%
happened in the last
sort of example and here?

00:42:13.770 --> 00:42:14.960 align:middle line:90%
Or is this OK so far?

00:42:14.960 --> 00:42:18.590 align:middle line:90%


00:42:18.590 --> 00:42:20.260 align:middle line:90%
OK.

00:42:20.260 --> 00:42:22.670 align:middle line:90%
So now I've set up my code.

00:42:22.670 --> 00:42:25.240 align:middle line:84%
And this is where the
interesting part comes in.

00:42:25.240 --> 00:42:29.170 align:middle line:84%
Make_prod is going to
finish its call by saying,

00:42:29.170 --> 00:42:30.820 align:middle line:90%
I'm going to return something.

00:42:30.820 --> 00:42:34.310 align:middle line:90%
And the thing it returns is g.

00:42:34.310 --> 00:42:38.120 align:middle line:90%
So it returns this name g.

00:42:38.120 --> 00:42:40.130 align:middle line:84%
It happens to be
a function object,

00:42:40.130 --> 00:42:42.410 align:middle line:84%
but think of it
as anything else.

00:42:42.410 --> 00:42:45.530 align:middle line:84%
We're basically saying doubler
equals 10 or doubler equals

00:42:45.530 --> 00:42:46.970 align:middle line:90%
some list or some tuple.

00:42:46.970 --> 00:42:50.150 align:middle line:84%
Doubler is going
to be some value.

00:42:50.150 --> 00:42:55.500 align:middle line:84%
This value is just code
associated with a function.

00:42:55.500 --> 00:42:57.770 align:middle line:84%
So in my main
program scope, I've

00:42:57.770 --> 00:43:01.280 align:middle line:84%
got doubler equals g, which
based on the memory diagram we

00:43:01.280 --> 00:43:04.040 align:middle line:84%
did 5 or 10 slides
ago, it's like when

00:43:04.040 --> 00:43:06.350 align:middle line:90%
we had myfunc equals is_even.

00:43:06.350 --> 00:43:11.840 align:middle line:84%
I basically have two names
for the same function object.

00:43:11.840 --> 00:43:15.110 align:middle line:84%
Doubler is a name, and
g is the other name.

00:43:15.110 --> 00:43:18.965 align:middle line:84%
And they both point to
this function object.

00:43:18.965 --> 00:43:22.630 align:middle line:90%


00:43:22.630 --> 00:43:24.090 align:middle line:90%
Does that make sense?

00:43:24.090 --> 00:43:26.890 align:middle line:90%
Is that OK?

00:43:26.890 --> 00:43:28.420 align:middle line:90%
OK.

00:43:28.420 --> 00:43:31.360 align:middle line:84%
So now that I've got two names
that point to the same function

00:43:31.360 --> 00:43:37.550 align:middle line:84%
object, we can just use this
doubler in the next line.

00:43:37.550 --> 00:43:46.280 align:middle line:84%
And this doubler is like
saying g parentheses 3,

00:43:46.280 --> 00:43:50.260 align:middle line:84%
except that I'm using
the name [AUDIO OUT]

00:43:50.260 --> 01:15:31.000 align:middle line:90%