WEBVTT

00:00:00.000 --> 00:00:01.924 align:middle line:90%
[SQUEAKING]

00:00:01.924 --> 00:00:03.848 align:middle line:90%
[RUSTLING]

00:00:03.848 --> 00:00:05.772 align:middle line:90%
[CLICKING]

00:00:05.772 --> 00:00:11.517 align:middle line:90%


00:00:11.517 --> 00:00:12.350 align:middle line:90%
ANA BELL: All right.

00:00:12.350 --> 00:00:13.850 align:middle line:90%
So, hello, everyone.

00:00:13.850 --> 00:00:16.810 align:middle line:90%
Let's get started.

00:00:16.810 --> 00:00:17.930 align:middle line:90%
This is lecture 10.

00:00:17.930 --> 00:00:21.980 align:middle line:84%
So last lecture, we
introduced two new data types.

00:00:21.980 --> 00:00:25.690 align:middle line:84%
We talked about a data type
called a tuple and a data type

00:00:25.690 --> 00:00:27.250 align:middle line:90%
called a list.

00:00:27.250 --> 00:00:30.142 align:middle line:84%
So today, we're not going to
talk about tuples anymore,

00:00:30.142 --> 00:00:31.850 align:middle line:84%
because they were
pretty straightforward.

00:00:31.850 --> 00:00:33.460 align:middle line:84%
A lot of operations you
could do with strings,

00:00:33.460 --> 00:00:34.760 align:middle line:90%
you could do with tuples.

00:00:34.760 --> 00:00:36.558 align:middle line:90%
They were immutable objects.

00:00:36.558 --> 00:00:38.350 align:middle line:84%
That means once you
created them in memory,

00:00:38.350 --> 00:00:40.130 align:middle line:84%
you couldn't do
anything to change them.

00:00:40.130 --> 00:00:42.250 align:middle line:84%
And so they were, I
guess, pretty boring,

00:00:42.250 --> 00:00:46.180 align:middle line:84%
except that you could
populate tuples with objects

00:00:46.180 --> 00:00:47.720 align:middle line:90%
that were of any type.

00:00:47.720 --> 00:00:50.020 align:middle line:84%
So you could populate
a tuple with integers

00:00:50.020 --> 00:00:53.440 align:middle line:84%
and floats and Booleans
and other tuples all

00:00:53.440 --> 00:00:55.480 align:middle line:90%
at the same time.

00:00:55.480 --> 00:00:58.420 align:middle line:84%
We introduced lists
last time as well as

00:00:58.420 --> 00:01:01.420 align:middle line:84%
something that was really
similar to tuples and strings

00:01:01.420 --> 00:01:04.209 align:middle line:90%
in terms of manipulations.

00:01:04.209 --> 00:01:07.340 align:middle line:84%
Lists were also nice because
you could populate them, again,

00:01:07.340 --> 00:01:11.170 align:middle line:84%
with any kind of data objects,
just like you could tuples.

00:01:11.170 --> 00:01:13.060 align:middle line:84%
Today what we're
going to focus on,

00:01:13.060 --> 00:01:15.220 align:middle line:84%
though, is the
idea of mutability

00:01:15.220 --> 00:01:18.200 align:middle line:84%
when talking about lists,
which is something new.

00:01:18.200 --> 00:01:20.913 align:middle line:84%
We have never talked
about this idea before.

00:01:20.913 --> 00:01:22.330 align:middle line:84%
And so this lecture
is going to be

00:01:22.330 --> 00:01:26.290 align:middle line:84%
pretty heavy on that idea and
a little bit heavy on syntax

00:01:26.290 --> 00:01:30.910 align:middle line:84%
and things like that to remind
you of how to manipulate

00:01:30.910 --> 00:01:32.810 align:middle line:90%
these compound data types.

00:01:32.810 --> 00:01:35.560 align:middle line:84%
So please, if there's any
questions, feel free to stop me,

00:01:35.560 --> 00:01:38.680 align:middle line:84%
and then I can go over what
I just talked about if there

00:01:38.680 --> 00:01:40.270 align:middle line:90%
was anything confusing.

00:01:40.270 --> 00:01:43.540 align:middle line:84%
So this slide is
basically a copy

00:01:43.540 --> 00:01:46.550 align:middle line:84%
of the slide we had
on lists last lecture.

00:01:46.550 --> 00:01:48.460 align:middle line:84%
It shows a bunch of
different-- oops,

00:01:48.460 --> 00:01:51.650 align:middle line:84%
a bunch of different operations
that you can do with lists.

00:01:51.650 --> 00:01:53.740 align:middle line:84%
They're very similar
to operations

00:01:53.740 --> 00:01:55.300 align:middle line:90%
that you can do with strings.

00:01:55.300 --> 00:01:57.770 align:middle line:84%
So here I'm just
creating an empty list.

00:01:57.770 --> 00:02:00.740 align:middle line:84%
I'm creating a list with
a bunch of elements in it.

00:02:00.740 --> 00:02:04.600 align:middle line:84%
So here we can see that this
list contains four elements,

00:02:04.600 --> 00:02:07.190 align:middle line:84%
and they are all
of different types.

00:02:07.190 --> 00:02:09.620 align:middle line:84%
This is an integer, this is
a string, this is an integer,

00:02:09.620 --> 00:02:10.669 align:middle line:90%
and this is another list.

00:02:10.669 --> 00:02:15.150 align:middle line:84%
And that's totally OK to
do with these data types.

00:02:15.150 --> 00:02:18.270 align:middle line:84%
Doing all of these operations,
getting the length, indexing,

00:02:18.270 --> 00:02:20.640 align:middle line:84%
slicing, concatenation,
getting the max,

00:02:20.640 --> 00:02:24.120 align:middle line:84%
all that should be
review, as well as

00:02:24.120 --> 00:02:28.210 align:middle line:84%
iterating a for loop over the
elements in a list directly.

00:02:28.210 --> 00:02:30.300 align:middle line:84%
So just like we
iterated a for loop

00:02:30.300 --> 00:02:34.410 align:middle line:84%
over characters in a
string, this loop basically

00:02:34.410 --> 00:02:37.200 align:middle line:84%
makes e, our loop
variable, take on the value

00:02:37.200 --> 00:02:40.410 align:middle line:84%
of every single
element in our list L.

00:02:40.410 --> 00:02:42.930 align:middle line:84%
What's new, the
bolded thing here

00:02:42.930 --> 00:02:45.300 align:middle line:84%
is something we haven't
been able to do before.

00:02:45.300 --> 00:02:49.230 align:middle line:84%
And this basically
goes into memory

00:02:49.230 --> 00:02:53.610 align:middle line:84%
and changes the element
at index 3 and L.

00:02:53.610 --> 00:02:55.830 align:middle line:84%
So that's kind of
how we read that.

00:02:55.830 --> 00:02:59.400 align:middle line:84%
And it changes that element to
have the value on the right hand

00:02:59.400 --> 00:03:00.240 align:middle line:90%
side.

00:03:00.240 --> 00:03:03.330 align:middle line:84%
So this is kind of, I mean,
we read it in the same way

00:03:03.330 --> 00:03:05.260 align:middle line:84%
as we do other
assignment statements.

00:03:05.260 --> 00:03:07.990 align:middle line:84%
We look at the right hand
side and we evaluate that.

00:03:07.990 --> 00:03:10.290 align:middle line:90%
In this case, it's only a 10.

00:03:10.290 --> 00:03:12.460 align:middle line:84%
But the left hand
side looks different.

00:03:12.460 --> 00:03:14.790 align:middle line:84%
It's not a variable name
as we have seen before,

00:03:14.790 --> 00:03:17.250 align:middle line:90%
but in fact, it's this.

00:03:17.250 --> 00:03:22.560 align:middle line:84%
It's referencing the item
in list named L at index 3.

00:03:22.560 --> 00:03:26.380 align:middle line:84%
So that would be
index 0 1, 2, 3.

00:03:26.380 --> 00:03:29.940 align:middle line:84%
This line of code down there,
L squared brackets 3 equals 10,

00:03:29.940 --> 00:03:35.970 align:middle line:84%
basically replaces this entire
element here with the number 10.

00:03:35.970 --> 00:03:40.410 align:middle line:84%
So on the next few slides, we're
going to talk about what exactly

00:03:40.410 --> 00:03:47.040 align:middle line:84%
this means inside memory,
because it's different than what

00:03:47.040 --> 00:03:49.190 align:middle line:90%
we've been doing before.

00:03:49.190 --> 00:03:54.230 align:middle line:84%
So what exactly happens when
we go into a mutable object,

00:03:54.230 --> 00:04:00.680 align:middle line:84%
like a list, and we change an
element using this exact syntax?

00:04:00.680 --> 00:04:03.290 align:middle line:84%
All right, well, let's draw
our memory diagrams the way

00:04:03.290 --> 00:04:04.740 align:middle line:90%
we have been in the past.

00:04:04.740 --> 00:04:07.220 align:middle line:84%
Here's our little cloud
representing the memory.

00:04:07.220 --> 00:04:11.320 align:middle line:84%
L equals 2, 4, 3 creates
this list for me in memory,

00:04:11.320 --> 00:04:12.780 align:middle line:90%
this list object.

00:04:12.780 --> 00:04:16.820 align:middle line:84%
And L is the name that I'm
referencing to this list object.

00:04:16.820 --> 00:04:20.720 align:middle line:84%
So I'm basically binding the
name L to that object in memory.

00:04:20.720 --> 00:04:27.440 align:middle line:84%
L square brackets 1 equals 5
tells Python to follow the name

00:04:27.440 --> 00:04:31.230 align:middle line:84%
L to the object in
memory and then look up

00:04:31.230 --> 00:04:33.060 align:middle line:84%
the index in the
square brackets.

00:04:33.060 --> 00:04:34.420 align:middle line:90%
In this case, index 1.

00:04:34.420 --> 00:04:36.570 align:middle line:90%
So that's 0, 1 this 4.

00:04:36.570 --> 00:04:39.870 align:middle line:84%
And take the element
at this location

00:04:39.870 --> 00:04:43.510 align:middle line:84%
and override it to be whatever
the right hand side says.

00:04:43.510 --> 00:04:45.160 align:middle line:90%
So the right hand side says 5.

00:04:45.160 --> 00:04:46.770 align:middle line:84%
So basically, we're
going into memory

00:04:46.770 --> 00:04:50.760 align:middle line:84%
and changing that
middle element.

00:04:50.760 --> 00:04:53.080 align:middle line:84%
So this is different
than strings and tuples.

00:04:53.080 --> 00:04:55.710 align:middle line:84%
We were not allowed to
do anything like this

00:04:55.710 --> 00:04:57.450 align:middle line:90%
with strings and tuples.

00:04:57.450 --> 00:05:01.020 align:middle line:84%
So let's look at an
example on the next slide

00:05:01.020 --> 00:05:02.020 align:middle line:90%
about what this means.

00:05:02.020 --> 00:05:03.960 align:middle line:84%
But the idea here
I'm trying to get

00:05:03.960 --> 00:05:08.700 align:middle line:84%
at is this object that we have
changed one of the elements

00:05:08.700 --> 00:05:10.770 align:middle line:90%
inside--

00:05:10.770 --> 00:05:12.900 align:middle line:84%
for which we've changed
one of the elements,

00:05:12.900 --> 00:05:14.830 align:middle line:90%
we've changed the object itself.

00:05:14.830 --> 00:05:16.270 align:middle line:90%
We didn't make a new copy.

00:05:16.270 --> 00:05:18.520 align:middle line:84%
We didn't kind of make a
version of that object.

00:05:18.520 --> 00:05:21.790 align:middle line:84%
We have changed
the object itself.

00:05:21.790 --> 00:05:26.760 align:middle line:84%
So let's see maybe similar
code that you might think

00:05:26.760 --> 00:05:30.680 align:middle line:84%
does the same thing,
except with tuples.

00:05:30.680 --> 00:05:31.180 align:middle line:90%
All right.

00:05:31.180 --> 00:05:34.270 align:middle line:84%
So the first two lines of
code are going to be the same.

00:05:34.270 --> 00:05:37.920 align:middle line:84%
We've got L in memory
being the object 2, 4, 3.

00:05:37.920 --> 00:05:41.430 align:middle line:84%
Or L being the name bound
to the object 2, 4, 3.

00:05:41.430 --> 00:05:42.880 align:middle line:90%
L square brackets 1.

00:05:42.880 --> 00:05:49.890 align:middle line:84%
So L at index 1 equals 5 changes
that middle element to be a 5.

00:05:49.890 --> 00:05:51.550 align:middle line:90%
Same as the previous slide.

00:05:51.550 --> 00:05:54.430 align:middle line:84%
Now, what if we had
these two lines of code?

00:05:54.430 --> 00:05:57.990 align:middle line:84%
t is going to be a
variable name that's

00:05:57.990 --> 00:06:00.100 align:middle line:90%
bound to the tuple 2, 4, 3.

00:06:00.100 --> 00:06:03.780 align:middle line:84%
So notice this is now the
tuple denoted in parentheses.

00:06:03.780 --> 00:06:06.456 align:middle line:90%
If I say t is equal to 2, 5.

00:06:06.456 --> 00:06:09.630 align:middle line:90%
3, what happens?

00:06:09.630 --> 00:06:14.130 align:middle line:84%
Basically with this line, I am
creating a new object in memory.

00:06:14.130 --> 00:06:15.990 align:middle line:90%
So there's my new object.

00:06:15.990 --> 00:06:18.930 align:middle line:84%
And I'm taking
the name t and I'm

00:06:18.930 --> 00:06:21.430 align:middle line:90%
binding it to this new object.

00:06:21.430 --> 00:06:27.450 align:middle line:84%
The old object, 2, 4, 3 as a
tuple, still remains in memory.

00:06:27.450 --> 00:06:29.930 align:middle line:84%
I have not modified
that object at all.

00:06:29.930 --> 00:06:30.740 align:middle line:90%
It's still there.

00:06:30.740 --> 00:06:32.770 align:middle line:84%
I've just lost
the binding to it.

00:06:32.770 --> 00:06:37.670 align:middle line:84%
So the name t is separate from
the actual object in memory.

00:06:37.670 --> 00:06:41.260 align:middle line:84%
In terms of tuples, what
that means for us is

00:06:41.260 --> 00:06:44.320 align:middle line:84%
we can never change the
tuple object in memory

00:06:44.320 --> 00:06:45.710 align:middle line:90%
once we've created it.

00:06:45.710 --> 00:06:49.870 align:middle line:84%
But with lists using
this specific operation,

00:06:49.870 --> 00:06:52.820 align:middle line:84%
this one right here, L
square brackets 1 equals 5,

00:06:52.820 --> 00:06:55.330 align:middle line:84%
this does allow us
to go into memory

00:06:55.330 --> 00:06:58.510 align:middle line:84%
and literally change
that object that

00:06:58.510 --> 00:07:01.500 align:middle line:90%
is associated with the name L.

00:07:01.500 --> 00:07:02.920 align:middle line:90%
Is everyone OK with this slide?

00:07:02.920 --> 00:07:03.880 align:middle line:90%
Does this make sense?

00:07:03.880 --> 00:07:05.470 align:middle line:90%
This showcases the difference.

00:07:05.470 --> 00:07:06.870 align:middle line:84%
So we need to
think about what is

00:07:06.870 --> 00:07:10.400 align:middle line:84%
the name of the object versus
the object itself in memory.

00:07:10.400 --> 00:07:14.225 align:middle line:90%


00:07:14.225 --> 00:07:17.140 align:middle line:84%
So that shows you
how to create a list

00:07:17.140 --> 00:07:20.770 align:middle line:84%
and then go ahead and change
elements to different values

00:07:20.770 --> 00:07:21.960 align:middle line:90%
within that list.

00:07:21.960 --> 00:07:27.340 align:middle line:84%
But now that we have a list
object that we can mutate,

00:07:27.340 --> 00:07:30.310 align:middle line:84%
other operations we can do
with it is to, let's say,

00:07:30.310 --> 00:07:32.210 align:middle line:84%
add more items to
the end of the list.

00:07:32.210 --> 00:07:35.220 align:middle line:90%
So we can make the list bigger.

00:07:35.220 --> 00:07:37.770 align:middle line:84%
We can mutate the object
by doing that using

00:07:37.770 --> 00:07:40.110 align:middle line:90%
this append function.

00:07:40.110 --> 00:07:44.160 align:middle line:84%
Now, I'm going to talk about the
syntax of the append function

00:07:44.160 --> 00:07:45.580 align:middle line:90%
in a little bit.

00:07:45.580 --> 00:07:47.520 align:middle line:84%
But basically, if
I want to mutate

00:07:47.520 --> 00:07:51.250 align:middle line:84%
L to add an item to the end of
it, I have to use the syntax.

00:07:51.250 --> 00:07:55.710 align:middle line:84%
There isn't a different form, a
different function to do this.

00:07:55.710 --> 00:08:00.060 align:middle line:84%
So this specific
syntax has to be used.

00:08:00.060 --> 00:08:02.420 align:middle line:84%
Append is basically
the function name.

00:08:02.420 --> 00:08:04.990 align:middle line:90%


00:08:04.990 --> 00:08:07.850 align:middle line:84%
Element is going to
be the parameter,

00:08:07.850 --> 00:08:11.230 align:middle line:84%
the thing that I want to add
on to the end of my list.

00:08:11.230 --> 00:08:14.050 align:middle line:84%
And L, the thing
before the dot, is

00:08:14.050 --> 00:08:18.010 align:middle line:84%
going to be the object I
want to add the element

00:08:18.010 --> 00:08:19.190 align:middle line:90%
to the end of the list.

00:08:19.190 --> 00:08:23.740 align:middle line:84%
So L, in this case, I'm
using it generically,

00:08:23.740 --> 00:08:26.950 align:middle line:84%
but you can imagine
creating a list of employees

00:08:26.950 --> 00:08:28.263 align:middle line:90%
in your company.

00:08:28.263 --> 00:08:29.930 align:middle line:84%
Then you might name
that list employees.

00:08:29.930 --> 00:08:33.549 align:middle line:84%
In that case, we would
say employees.append Ana

00:08:33.549 --> 00:08:34.820 align:middle line:90%
or whatever.

00:08:34.820 --> 00:08:37.270 align:middle line:84%
So that L is just kind
of generic for now,

00:08:37.270 --> 00:08:39.850 align:middle line:84%
but it gets replaced with
whatever variable name

00:08:39.850 --> 00:08:41.320 align:middle line:90%
your list is.

00:08:41.320 --> 00:08:45.400 align:middle line:84%
So this operation
basically mutates the list.

00:08:45.400 --> 00:08:49.510 align:middle line:84%
So it mutates it to be
one extra element longer.

00:08:49.510 --> 00:08:51.742 align:middle line:84%
And the element you're adding
to the end of the list,

00:08:51.742 --> 00:08:53.200 align:middle line:84%
to the right hand
side of the list,

00:08:53.200 --> 00:08:57.340 align:middle line:84%
is going to be whatever is
in the parentheses to append.

00:08:57.340 --> 00:08:59.030 align:middle line:90%
So let's look at an example.

00:08:59.030 --> 00:09:02.930 align:middle line:84%
So we're going to create L is
equal to 2, 1, 3 in memory.

00:09:02.930 --> 00:09:05.903 align:middle line:84%
And then let's say
we do L.append 5.

00:09:05.903 --> 00:09:08.970 align:middle line:90%


00:09:08.970 --> 00:09:11.480 align:middle line:84%
Well, this line of
code says, look up

00:09:11.480 --> 00:09:14.840 align:middle line:84%
L. It's this object in
memory here, 2, 1, 3.

00:09:14.840 --> 00:09:18.388 align:middle line:84%
And add the object
5 to the end of it.

00:09:18.388 --> 00:09:20.430 align:middle line:84%
So I'm going to add the
5 to the end of the list.

00:09:20.430 --> 00:09:22.310 align:middle line:84%
Now, it's no longer
three elements long.

00:09:22.310 --> 00:09:23.730 align:middle line:90%
It's four elements long.

00:09:23.730 --> 00:09:25.200 align:middle line:90%
And again, I didn't make a copy.

00:09:25.200 --> 00:09:28.650 align:middle line:84%
I didn't preserve the original
list with just 2 and 3 in it.

00:09:28.650 --> 00:09:31.070 align:middle line:84%
I have literally changed
this list in memory.

00:09:31.070 --> 00:09:34.380 align:middle line:90%
That's referenced by L.

00:09:34.380 --> 00:09:39.720 align:middle line:84%
Now, this function append
is being used basically

00:09:39.720 --> 00:09:40.870 align:middle line:90%
for its side effect.

00:09:40.870 --> 00:09:46.050 align:middle line:84%
And the side effect here
is mutating the list.

00:09:46.050 --> 00:09:51.780 align:middle line:84%
After the function adds the
5 in this particular case

00:09:51.780 --> 00:09:53.790 align:middle line:84%
to the end of the
list, the function

00:09:53.790 --> 00:09:56.200 align:middle line:84%
doesn't need to
return anything back.

00:09:56.200 --> 00:09:59.460 align:middle line:84%
It's basically done its
job to do the mutation.

00:09:59.460 --> 00:10:02.940 align:middle line:84%
And so functions like
append, and we're

00:10:02.940 --> 00:10:04.620 align:middle line:84%
going to see other
functions later,

00:10:04.620 --> 00:10:07.700 align:middle line:90%
don't have any return value.

00:10:07.700 --> 00:10:11.400 align:middle line:84%
So one really common
mistake as we're

00:10:11.400 --> 00:10:14.310 align:middle line:84%
kind of learning about
mutable excuse objects

00:10:14.310 --> 00:10:16.800 align:middle line:84%
and using these functions
that mutate is to say,

00:10:16.800 --> 00:10:20.550 align:middle line:84%
well, I'm going to do
L.append 5 and save

00:10:20.550 --> 00:10:23.400 align:middle line:84%
this, the result
of this function,

00:10:23.400 --> 00:10:27.340 align:middle line:84%
back into the variable named
L. And this would be incorrect.

00:10:27.340 --> 00:10:29.310 align:middle line:84%
So let's see if we do
this line of code what

00:10:29.310 --> 00:10:31.410 align:middle line:90%
exactly will happen.

00:10:31.410 --> 00:10:33.160 align:middle line:90%
So it's an assignment.

00:10:33.160 --> 00:10:35.820 align:middle line:84%
So the first thing we do is
we look at the right hand side

00:10:35.820 --> 00:10:37.390 align:middle line:90%
and we evaluate that.

00:10:37.390 --> 00:10:39.390 align:middle line:84%
Well, the right
hand side basically

00:10:39.390 --> 00:10:41.820 align:middle line:84%
says L.append 5, which
is exactly the same

00:10:41.820 --> 00:10:43.180 align:middle line:90%
as the previous line.

00:10:43.180 --> 00:10:46.500 align:middle line:84%
So we're going to put another
5 to the end of our currently

00:10:46.500 --> 00:10:48.480 align:middle line:90%
mutated list.

00:10:48.480 --> 00:10:52.740 align:middle line:84%
Just kind of going with
these operations in order.

00:10:52.740 --> 00:10:56.250 align:middle line:84%
And then I said this function,
this append function,

00:10:56.250 --> 00:10:59.310 align:middle line:84%
has done its job to
mutate the list by adding

00:10:59.310 --> 00:11:00.550 align:middle line:90%
a 5 to the end of it.

00:11:00.550 --> 00:11:01.882 align:middle line:90%
So it returns nothing.

00:11:01.882 --> 00:11:04.590 align:middle line:84%
There's nothing of value that it
could return, because it already

00:11:04.590 --> 00:11:06.340 align:middle line:90%
did its job of mutation.

00:11:06.340 --> 00:11:09.720 align:middle line:90%
So it actually returns none.

00:11:09.720 --> 00:11:12.510 align:middle line:84%
So the assignment,
the equal sign,

00:11:12.510 --> 00:11:15.240 align:middle line:84%
then basically says,
take the name L

00:11:15.240 --> 00:11:19.782 align:middle line:84%
and bind it to the return
of this function L.append 5.

00:11:19.782 --> 00:11:21.490 align:middle line:84%
Well, the return of
the function is none.

00:11:21.490 --> 00:11:25.360 align:middle line:84%
So basically, now we're
losing the binding from.

00:11:25.360 --> 00:11:28.600 align:middle line:84%
2, 1, 3, 5, 5, which
was our mutated list,

00:11:28.600 --> 00:11:32.350 align:middle line:84%
and rebinding it
to the return none.

00:11:32.350 --> 00:11:36.900 align:middle line:84%
So that is an incorrect way
to do the mutation of adding

00:11:36.900 --> 00:11:40.230 align:middle line:90%
an item to the end of the list.

00:11:40.230 --> 00:11:42.270 align:middle line:90%
Everyone OK with that so far?

00:11:42.270 --> 00:11:42.860 align:middle line:90%
Yes.

00:11:42.860 --> 00:11:43.360 align:middle line:90%
OK.

00:11:43.360 --> 00:11:43.860 align:middle line:90%
Excellent.

00:11:43.860 --> 00:11:46.380 align:middle line:84%
So what should we
have done instead?

00:11:46.380 --> 00:11:50.350 align:middle line:84%
Sorry, yes, be careful
about the append operation.

00:11:50.350 --> 00:11:54.220 align:middle line:84%
You're doing a mutation and
you return none as a result.

00:11:54.220 --> 00:11:58.450 align:middle line:84%
So you do not want to
resave this to any variable.

00:11:58.450 --> 00:12:04.300 align:middle line:84%
So instead, what we would do is
we would just do the operation.

00:12:04.300 --> 00:12:05.850 align:middle line:90%
There's nothing to save.

00:12:05.850 --> 00:12:08.320 align:middle line:84%
Nothing to save in
any return variable.

00:12:08.320 --> 00:12:10.980 align:middle line:84%
So if you wanted to add two
fives to the end of that list,

00:12:10.980 --> 00:12:13.470 align:middle line:84%
you would just say
L.append 5 again,

00:12:13.470 --> 00:12:18.100 align:middle line:84%
and L would then have been
mutated to be 2, 1, 3, 5, 5.

00:12:18.100 --> 00:12:21.150 align:middle line:84%
And so in your code,
if you just print L

00:12:21.150 --> 00:12:24.360 align:middle line:84%
in between these
appends, if you print

00:12:24.360 --> 00:12:29.320 align:middle line:84%
it L after the first L.append 5,
it would print this 2, 1, 3, 5.

00:12:29.320 --> 00:12:32.190 align:middle line:84%
And then if we print L
after the second append 5,

00:12:32.190 --> 00:12:33.930 align:middle line:90%
it would print 2, 1, 3, 5, 5.

00:12:33.930 --> 00:12:36.550 align:middle line:84%
Because it's an
ongoing operation.

00:12:36.550 --> 00:12:38.550 align:middle line:84%
It's mutating this
list, and now you're

00:12:38.550 --> 00:12:42.390 align:middle line:84%
doing operations on
the newly mutated list.

00:12:42.390 --> 00:12:44.767 align:middle line:90%
Everyone-- yeah.

00:12:44.767 --> 00:12:46.350 align:middle line:84%
STUDENT: For the
element, can you only

00:12:46.350 --> 00:12:49.740 align:middle line:84%
use one integer or can
you do [INAUDIBLE]??

00:12:49.740 --> 00:12:52.350 align:middle line:84%
ANA BELL: For the element,
do you have to do one integer

00:12:52.350 --> 00:12:53.980 align:middle line:90%
or can you use 5 comma 5?

00:12:53.980 --> 00:12:58.420 align:middle line:84%
So the append only
works with one thing.

00:12:58.420 --> 00:13:01.890 align:middle line:84%
So if you wanted
to append a tuple,

00:13:01.890 --> 00:13:03.990 align:middle line:84%
you could append one
tuple object that

00:13:03.990 --> 00:13:06.120 align:middle line:84%
has many things in
it, but it would just

00:13:06.120 --> 00:13:07.830 align:middle line:90%
append that one tuple.

00:13:07.830 --> 00:13:10.050 align:middle line:84%
We're going to see towards
the end of this lecture

00:13:10.050 --> 00:13:12.330 align:middle line:84%
an operation that
allows us to extend

00:13:12.330 --> 00:13:14.670 align:middle line:90%
the list by a bunch of items.

00:13:14.670 --> 00:13:18.830 align:middle line:84%
But there is a way,
just not with append.

00:13:18.830 --> 00:13:19.678 align:middle line:90%
Yeah?

00:13:19.678 --> 00:13:21.803 align:middle line:84%
STUDENT: Why did the other
thing return none again?

00:13:21.803 --> 00:13:24.840 align:middle line:84%
ANA BELL: So the other thing,
so this operation always

00:13:24.840 --> 00:13:25.750 align:middle line:90%
returns none.

00:13:25.750 --> 00:13:29.380 align:middle line:84%
L.append 5 or whatever, the
append always returns none.

00:13:29.380 --> 00:13:32.110 align:middle line:84%
But here it's just sitting
on a line by itself.

00:13:32.110 --> 00:13:34.450 align:middle line:84%
We're not saving it
back to anything.

00:13:34.450 --> 00:13:39.090 align:middle line:84%
In the previous one, we took the
return and saved it back into L.

00:13:39.090 --> 00:13:42.665 align:middle line:84%
And that's why we lost the
binding to the actual list.

00:13:42.665 --> 00:13:46.180 align:middle line:90%


00:13:46.180 --> 00:13:48.460 align:middle line:84%
So what we usually
say is that we

00:13:48.460 --> 00:13:51.190 align:middle line:84%
use append and a bunch of
these other mutable functions

00:13:51.190 --> 00:13:52.520 align:middle line:90%
for their side effects.

00:13:52.520 --> 00:13:54.190 align:middle line:84%
And the side effect
in this case is

00:13:54.190 --> 00:13:59.410 align:middle line:84%
to mutate the object that
I'm calling the append on.

00:13:59.410 --> 00:14:05.220 align:middle line:90%
In this case, the list named L.

00:14:05.220 --> 00:14:07.830 align:middle line:84%
So let's have you think
about this problem.

00:14:07.830 --> 00:14:09.120 align:middle line:90%
And while you do it--

00:14:09.120 --> 00:14:11.800 align:middle line:84%
and then we can write it
on the board together.

00:14:11.800 --> 00:14:16.590 align:middle line:84%
So as we go through these
lines of code one at a time,

00:14:16.590 --> 00:14:21.900 align:middle line:84%
what will the values
of the lists become?

00:14:21.900 --> 00:14:23.510 align:middle line:90%
So L1 is the string re.

00:14:23.510 --> 00:14:24.300 align:middle line:90%
L2 is mi.

00:14:24.300 --> 00:14:25.920 align:middle line:90%
L3 is do.

00:14:25.920 --> 00:14:31.342 align:middle line:84%
What is L4 going to be with
that line L4 equals L1 plus L2?

00:14:31.342 --> 00:14:32.050 align:middle line:90%
Does anyone know?

00:14:32.050 --> 00:14:36.340 align:middle line:90%


00:14:36.340 --> 00:14:37.605 align:middle line:90%
What's the type?

00:14:37.605 --> 00:14:41.090 align:middle line:90%


00:14:41.090 --> 00:14:42.510 align:middle line:90%
It's concatenation.

00:14:42.510 --> 00:14:45.480 align:middle line:84%
So concatenation with lists is
like concatenation with strings?

00:14:45.480 --> 00:14:46.287 align:middle line:90%
Yes?

00:14:46.287 --> 00:14:47.120 align:middle line:90%
STUDENT: [INAUDIBLE]

00:14:47.120 --> 00:14:48.560 align:middle line:90%
ANA BELL: Yep.

00:14:48.560 --> 00:14:50.546 align:middle line:90%
What are the elements in it?

00:14:50.546 --> 00:14:52.342 align:middle line:90%
STUDENT: [INAUDIBLE]

00:14:52.342 --> 00:14:55.440 align:middle line:90%


00:14:55.440 --> 00:14:57.750 align:middle line:90%
ANA BELL: Yep, exactly.

00:14:57.750 --> 00:15:00.710 align:middle line:84%
I'm not going to do the strings,
but you know what I mean.

00:15:00.710 --> 00:15:01.210 align:middle line:90%
All right.

00:15:01.210 --> 00:15:05.320 align:middle line:84%
So L4 with that line is
just these two elements

00:15:05.320 --> 00:15:07.300 align:middle line:90%
in a new list.

00:15:07.300 --> 00:15:11.080 align:middle line:84%
Now, what happens
with the next line?

00:15:11.080 --> 00:15:13.250 align:middle line:90%
L3.append L4.

00:15:13.250 --> 00:15:14.590 align:middle line:90%
Which one gets mutated?

00:15:14.590 --> 00:15:15.400 align:middle line:90%
L3 or L4?

00:15:15.400 --> 00:15:18.160 align:middle line:90%


00:15:18.160 --> 00:15:19.400 align:middle line:90%
L3 gets mutated.

00:15:19.400 --> 00:15:19.900 align:middle line:90%
Exactly.

00:15:19.900 --> 00:15:23.830 align:middle line:90%
And what does it get mutated to?

00:15:23.830 --> 00:15:27.140 align:middle line:90%
So L3 originally has do in it.

00:15:27.140 --> 00:15:29.580 align:middle line:84%
What am I adding
to the end of L3?

00:15:29.580 --> 00:15:35.210 align:middle line:90%


00:15:35.210 --> 00:15:38.490 align:middle line:90%
STUDENT: [INAUDIBLE]

00:15:38.490 --> 00:15:39.240 align:middle line:90%
ANA BELL: Exactly.

00:15:39.240 --> 00:15:40.840 align:middle line:90%
Yes, I'm adding one item.

00:15:40.840 --> 00:15:43.090 align:middle line:84%
And it's linked to the
question that was here.

00:15:43.090 --> 00:15:44.290 align:middle line:90%
What am I appending?

00:15:44.290 --> 00:15:45.520 align:middle line:90%
I'm appending one item.

00:15:45.520 --> 00:15:47.700 align:middle line:90%
It's whatever L4 is.

00:15:47.700 --> 00:15:49.510 align:middle line:90%
And L4 is this list.

00:15:49.510 --> 00:15:54.420 align:middle line:84%
So I'm going to be adding re
and mi within my list here.

00:15:54.420 --> 00:15:57.620 align:middle line:84%
And I've got to
close this list here.

00:15:57.620 --> 00:16:00.390 align:middle line:84%
So this is one item, one
object, one element, and this

00:16:00.390 --> 00:16:04.110 align:middle line:90%
is another element right here.

00:16:04.110 --> 00:16:05.435 align:middle line:90%
It just happens to be a list.

00:16:05.435 --> 00:16:08.560 align:middle line:90%


00:16:08.560 --> 00:16:09.940 align:middle line:90%
What about the next line?

00:16:09.940 --> 00:16:12.110 align:middle line:90%
L equals L1.append 3.

00:16:12.110 --> 00:16:16.650 align:middle line:84%
What is the right hand
side going to give me?

00:16:16.650 --> 00:16:19.693 align:middle line:90%
Am I mutating L1 or L3?

00:16:19.693 --> 00:16:20.193 align:middle line:90%
STUDENT: L1.

00:16:20.193 --> 00:16:21.490 align:middle line:90%
ANA BELL: Yes.

00:16:21.490 --> 00:16:23.780 align:middle line:90%
And what am I mutating L1 to be?

00:16:23.780 --> 00:16:25.030 align:middle line:90%
L1 is originally re.

00:16:25.030 --> 00:16:29.170 align:middle line:84%
And what am I adding
to the end of it?

00:16:29.170 --> 00:16:31.040 align:middle line:90%
STUDENT: [INAUDIBLE]

00:16:31.040 --> 00:16:32.130 align:middle line:90%
ANA BELL: Yeah, exactly.

00:16:32.130 --> 00:16:34.890 align:middle line:84%
This L3, which is
this big thing here.

00:16:34.890 --> 00:16:39.200 align:middle line:84%
So it's a list with two
elements, the first one being

00:16:39.200 --> 00:16:46.120 align:middle line:84%
a string and the second one
being another list like that.

00:16:46.120 --> 00:16:47.610 align:middle line:90%
So that's the right hand side.

00:16:47.610 --> 00:16:49.610 align:middle line:84%
And then what is the left
hand side going to be?

00:16:49.610 --> 00:16:51.380 align:middle line:90%
What is L going to be?

00:16:51.380 --> 00:16:51.970 align:middle line:90%
Yeah, exactly.

00:16:51.970 --> 00:16:55.400 align:middle line:90%


00:16:55.400 --> 00:16:55.900 align:middle line:90%
Exactly.

00:16:55.900 --> 00:16:59.390 align:middle line:90%


00:16:59.390 --> 00:17:02.480 align:middle line:84%
OK, so now that we've
introduced mutable objects,

00:17:02.480 --> 00:17:05.130 align:middle line:84%
we have to be careful about
what functions we're using.

00:17:05.130 --> 00:17:08.607 align:middle line:84%
Some of them mutate the list
and don't return anything.

00:17:08.607 --> 00:17:10.190 align:middle line:84%
Append is one of
them, and we're going

00:17:10.190 --> 00:17:12.470 align:middle line:84%
to see a few more
in today's lecture.

00:17:12.470 --> 00:17:15.680 align:middle line:84%
So these functions
are just being

00:17:15.680 --> 00:17:17.130 align:middle line:90%
used for their side effect.

00:17:17.130 --> 00:17:20.180 align:middle line:84%
They mutate the thing you're
calling the function on,

00:17:20.180 --> 00:17:21.687 align:middle line:90%
and that's it.

00:17:21.687 --> 00:17:22.770 align:middle line:90%
They don't need to return.

00:17:22.770 --> 00:17:23.819 align:middle line:90%
They don't return anything.

00:17:23.819 --> 00:17:25.277 align:middle line:84%
They don't need to
return anything.

00:17:25.277 --> 00:17:30.010 align:middle line:84%
They have done their job purely
by the mutation aspect of it.

00:17:30.010 --> 00:17:34.840 align:middle line:84%
So I want to just quickly
make an aside on this dot

00:17:34.840 --> 00:17:40.840 align:middle line:84%
notation that we've introduced
with this append function.

00:17:40.840 --> 00:17:44.110 align:middle line:84%
This is something we haven't
actually seen before,

00:17:44.110 --> 00:17:47.890 align:middle line:84%
but it's something that we
will learn about in the future

00:17:47.890 --> 00:17:50.530 align:middle line:84%
when we create our
own object types.

00:17:50.530 --> 00:17:52.330 align:middle line:84%
So right now we're
using object types

00:17:52.330 --> 00:17:55.560 align:middle line:84%
that somebody else wrote, like
a list or a tuple or something

00:17:55.560 --> 00:17:56.060 align:middle line:90%
like that.

00:17:56.060 --> 00:17:57.850 align:middle line:84%
But in a future
class, we're going

00:17:57.850 --> 00:18:00.470 align:middle line:84%
to learn how to create
our own object types.

00:18:00.470 --> 00:18:04.490 align:middle line:84%
And when we do, we're going to
use this dot notation a lot.

00:18:04.490 --> 00:18:08.320 align:middle line:84%
But for now, you basically just
kind of have to remember which

00:18:08.320 --> 00:18:11.090 align:middle line:84%
functions use dot
notation and which don't.

00:18:11.090 --> 00:18:14.080 align:middle line:84%
But I'll give you a little bit
of intuition for what this dot

00:18:14.080 --> 00:18:15.530 align:middle line:90%
notation actually means.

00:18:15.530 --> 00:18:19.060 align:middle line:84%
So when we have-- so everything
in Python is an object.

00:18:19.060 --> 00:18:22.320 align:middle line:84%
And when we have
objects in Python,

00:18:22.320 --> 00:18:28.370 align:middle line:84%
the idea here is that the
objects that you have have data

00:18:28.370 --> 00:18:29.610 align:middle line:90%
associated with them.

00:18:29.610 --> 00:18:31.890 align:middle line:90%
So what makes up the object.

00:18:31.890 --> 00:18:34.250 align:middle line:90%
And they have certain behaviors.

00:18:34.250 --> 00:18:36.920 align:middle line:84%
So we touched upon this
on maybe the first lecture

00:18:36.920 --> 00:18:40.350 align:middle line:84%
where we said things
you can do with integers

00:18:40.350 --> 00:18:43.290 align:middle line:84%
are different than the things
you can do with strings.

00:18:43.290 --> 00:18:45.070 align:middle line:90%
That's pretty clear.

00:18:45.070 --> 00:18:49.240 align:middle line:84%
And that's different than the
things you can do with lists.

00:18:49.240 --> 00:18:51.390 align:middle line:84%
And so the kinds
of things that you

00:18:51.390 --> 00:18:53.250 align:middle line:84%
could do with each one
of these object types

00:18:53.250 --> 00:18:55.380 align:middle line:90%
differs depending on the type.

00:18:55.380 --> 00:18:58.020 align:middle line:84%
And at its core,
really everything

00:18:58.020 --> 00:19:00.670 align:middle line:84%
can be written in terms
of this dot notation.

00:19:00.670 --> 00:19:03.450 align:middle line:84%
But some of the more
common operations,

00:19:03.450 --> 00:19:06.510 align:middle line:84%
like getting the length of
something or adding two numbers

00:19:06.510 --> 00:19:10.830 align:middle line:84%
together are actually-- we do
them in this shorthand notation,

00:19:10.830 --> 00:19:13.530 align:middle line:84%
like using the plus
operator or using the len.

00:19:13.530 --> 00:19:17.070 align:middle line:84%
But at their core, really, we
can take all of those operations

00:19:17.070 --> 00:19:19.120 align:middle line:84%
and convert them
to a dot notation.

00:19:19.120 --> 00:19:22.630 align:middle line:84%
We're not doing this today,
but that's what we can do.

00:19:22.630 --> 00:19:24.630 align:middle line:84%
And so when we see
this dot notation,

00:19:24.630 --> 00:19:26.820 align:middle line:84%
the way we usually read
it is we say, well,

00:19:26.820 --> 00:19:28.323 align:middle line:90%
what's to the left of the dot?

00:19:28.323 --> 00:19:30.240 align:middle line:84%
It's going to be our
object, the thing that we

00:19:30.240 --> 00:19:32.410 align:middle line:90%
want to do an operation on.

00:19:32.410 --> 00:19:36.160 align:middle line:84%
In this particular case,
it's a list named L,

00:19:36.160 --> 00:19:39.300 align:middle line:84%
but it could be a list
named employees or words

00:19:39.300 --> 00:19:45.750 align:middle line:84%
or whatever, book or whatever,
whatever the list name is.

00:19:45.750 --> 00:19:49.052 align:middle line:84%
The dot then comes
for the dot notation.

00:19:49.052 --> 00:19:50.760 align:middle line:84%
And then the thing on
the right hand side

00:19:50.760 --> 00:19:52.710 align:middle line:84%
is going to be the
operation that you

00:19:52.710 --> 00:19:56.470 align:middle line:84%
want to perform on the object
to the left of the dot.

00:19:56.470 --> 00:20:00.180 align:middle line:84%
So the operation, if you
basically cover up L dot,

00:20:00.180 --> 00:20:02.470 align:middle line:84%
the operation looks
just like a function.

00:20:02.470 --> 00:20:05.310 align:middle line:84%
It's append, parentheses,
some parameters.

00:20:05.310 --> 00:20:08.580 align:middle line:84%
And so the operation is
basically just a function

00:20:08.580 --> 00:20:12.090 align:middle line:84%
that you want to run on
an object of type list.

00:20:12.090 --> 00:20:16.980 align:middle line:84%
This specific object named L.
And you can see it has a name,

00:20:16.980 --> 00:20:19.780 align:middle line:84%
append, and it has
parameters or arguments.

00:20:19.780 --> 00:20:21.330 align:middle line:84%
In this case, it's
the thing you want

00:20:21.330 --> 00:20:23.990 align:middle line:90%
to add to the end of the list.

00:20:23.990 --> 00:20:26.900 align:middle line:84%
So again, unfortunately,
at this point in the class,

00:20:26.900 --> 00:20:30.050 align:middle line:84%
you just have to remember which
functions are dot notation

00:20:30.050 --> 00:20:31.500 align:middle line:90%
and which ones are not.

00:20:31.500 --> 00:20:35.570 align:middle line:84%
But it will become clear what
this dot notation actually means

00:20:35.570 --> 00:20:38.120 align:middle line:90%
towards the end of the class.

00:20:38.120 --> 00:20:42.160 align:middle line:84%
So let's have you work
on this little code here.

00:20:42.160 --> 00:20:44.300 align:middle line:84%
It's going to use
append, obviously,

00:20:44.300 --> 00:20:46.460 align:middle line:84%
and it's going to have
you create a list.

00:20:46.460 --> 00:20:49.070 align:middle line:84%
So the name of the function
you should make here

00:20:49.070 --> 00:20:50.430 align:middle line:90%
is called make ordered list.

00:20:50.430 --> 00:20:53.000 align:middle line:84%
And it takes in one
parameter, an integer n.

00:20:53.000 --> 00:20:54.330 align:middle line:90%
It's positive.

00:20:54.330 --> 00:20:59.600 align:middle line:84%
And I want you to create
for me a list that

00:20:59.600 --> 00:21:03.530 align:middle line:84%
has all of the integers from 0
all the way up to and including

00:21:03.530 --> 00:21:05.730 align:middle line:90%
n inside that list in order.

00:21:05.730 --> 00:21:14.910 align:middle line:84%
So as an example, down
in here around 34.

00:21:14.910 --> 00:21:16.970 align:middle line:84%
If we call make
ordered list with 6,

00:21:16.970 --> 00:21:21.740 align:middle line:84%
it's going to create for us
this list inside the function

00:21:21.740 --> 00:21:25.967 align:middle line:90%
and return this list.

00:21:25.967 --> 00:21:27.550 align:middle line:84%
So a couple of minutes
to work on that

00:21:27.550 --> 00:21:28.967 align:middle line:84%
and then we can
write it together.

00:21:28.967 --> 00:21:31.720 align:middle line:90%


00:21:31.720 --> 00:21:32.720 align:middle line:90%
All right.

00:21:32.720 --> 00:21:35.850 align:middle line:84%
What's the first thing
we should do here?

00:21:35.850 --> 00:21:37.520 align:middle line:84%
Or how would you
approach this problem?

00:21:37.520 --> 00:21:40.220 align:middle line:90%


00:21:40.220 --> 00:21:41.840 align:middle line:90%
Yes.

00:21:41.840 --> 00:21:44.160 align:middle line:84%
You want to create
an empty list.

00:21:44.160 --> 00:21:47.180 align:middle line:90%
What do you want to name it?

00:21:47.180 --> 00:21:49.950 align:middle line:90%
You named it list.

00:21:49.950 --> 00:21:52.320 align:middle line:84%
List is an OK name,
but notice list

00:21:52.320 --> 00:21:55.090 align:middle line:84%
is also the name of
the type of the object.

00:21:55.090 --> 00:21:59.280 align:middle line:84%
So I would refrain from
naming anything things that

00:21:59.280 --> 00:22:00.610 align:middle line:90%
change color.

00:22:00.610 --> 00:22:04.030 align:middle line:84%
So we can use L or
my list or whatever.

00:22:04.030 --> 00:22:05.430 align:middle line:90%
Something else.

00:22:05.430 --> 00:22:07.690 align:middle line:90%
My list is an empty list.

00:22:07.690 --> 00:22:09.190 align:middle line:84%
All right, so it's
originally empty,

00:22:09.190 --> 00:22:11.148 align:middle line:84%
and now we need to populate
it with some stuff.

00:22:11.148 --> 00:22:14.015 align:middle line:90%


00:22:14.015 --> 00:22:14.890 align:middle line:90%
Do you want to go on?

00:22:14.890 --> 00:22:15.932 align:middle line:90%
STUDENT: Make a for loop.

00:22:15.932 --> 00:22:17.080 align:middle line:90%
ANA BELL: Make a for loop.

00:22:17.080 --> 00:22:19.090 align:middle line:90%
That goes over what?

00:22:19.090 --> 00:22:22.740 align:middle line:90%
STUDENT: [INAUDIBLE]

00:22:22.740 --> 00:22:23.490 align:middle line:90%
ANA BELL: Yup.

00:22:23.490 --> 00:22:25.120 align:middle line:90%
0 to n plus 1.

00:22:25.120 --> 00:22:25.620 align:middle line:90%
Exactly.

00:22:25.620 --> 00:22:29.920 align:middle line:84%
Because we need our boundary
to go up to and including n.

00:22:29.920 --> 00:22:30.880 align:middle line:90%
Perfect.

00:22:30.880 --> 00:22:36.820 align:middle line:84%
So now that I've got I changing
to be 0, then 1, then 2, then 3,

00:22:36.820 --> 00:22:40.860 align:middle line:90%
what do I need to do to my list?

00:22:40.860 --> 00:22:42.040 align:middle line:90%
Yeah, exactly.

00:22:42.040 --> 00:22:42.640 align:middle line:90%
Append i.

00:22:42.640 --> 00:22:44.820 align:middle line:84%
So my list is the
name of the list

00:22:44.820 --> 00:22:54.250 align:middle line:84%
I've created dot append I. The
last thing, return the list.

00:22:54.250 --> 00:22:56.920 align:middle line:90%
So return my list.

00:22:56.920 --> 00:22:59.430 align:middle line:90%
So run it.

00:22:59.430 --> 00:23:00.540 align:middle line:90%
Perfect.

00:23:00.540 --> 00:23:06.190 align:middle line:84%
If we change this
to 2, still works.

00:23:06.190 --> 00:23:07.720 align:middle line:84%
So just testing it
out with a couple

00:23:07.720 --> 00:23:11.650 align:middle line:84%
different inputs just
to make sure it works.

00:23:11.650 --> 00:23:14.840 align:middle line:90%
Questions about this code?

00:23:14.840 --> 00:23:15.500 align:middle line:90%
Yeah.

00:23:15.500 --> 00:23:19.370 align:middle line:90%
STUDENT: [INAUDIBLE]

00:23:19.370 --> 00:23:21.630 align:middle line:84%
ANA BELL: The 0 is not
necessary in the range.

00:23:21.630 --> 00:23:22.485 align:middle line:90%
It defaults to 0.

00:23:22.485 --> 00:23:22.985 align:middle line:90%
Exactly.

00:23:22.985 --> 00:23:31.010 align:middle line:90%


00:23:31.010 --> 00:23:32.290 align:middle line:90%
We're not done yet.

00:23:32.290 --> 00:23:33.750 align:middle line:90%
You have more writing to do.

00:23:33.750 --> 00:23:38.120 align:middle line:84%
So let's write a slightly
different function now called

00:23:38.120 --> 00:23:39.710 align:middle line:90%
remove LM.

00:23:39.710 --> 00:23:41.610 align:middle line:90%
It takes in two parameters.

00:23:41.610 --> 00:23:45.890 align:middle line:84%
The first one is a
list, and the second one

00:23:45.890 --> 00:23:49.145 align:middle line:84%
is going to be
just some variable.

00:23:49.145 --> 00:23:51.020 align:middle line:84%
It could be an integer,
it could be a string,

00:23:51.020 --> 00:23:52.760 align:middle line:90%
it could be whatever.

00:23:52.760 --> 00:23:57.620 align:middle line:84%
And what the function should
do is create a new list,

00:23:57.620 --> 00:24:02.540 align:middle line:84%
populate it with the same
elements of L in the same order,

00:24:02.540 --> 00:24:06.183 align:middle line:84%
but exclude the ones
that are equal to e.

00:24:06.183 --> 00:24:08.600 align:middle line:84%
So you don't want to include
the ones that are equal to e.

00:24:08.600 --> 00:24:11.450 align:middle line:84%
Otherwise, keep everything
in the original list

00:24:11.450 --> 00:24:13.130 align:middle line:90%
L in the same order.

00:24:13.130 --> 00:24:19.310 align:middle line:84%
So as an example here, we've got
if our input list is 1, 2, 2, 2,

00:24:19.310 --> 00:24:22.370 align:middle line:84%
2, and I call the
function with L

00:24:22.370 --> 00:24:27.410 align:middle line:84%
and 2, the list that this
function returns should just

00:24:27.410 --> 00:24:29.400 align:middle line:90%
contain one element in it.

00:24:29.400 --> 00:24:30.350 align:middle line:90%
Just the one.

00:24:30.350 --> 00:24:33.700 align:middle line:90%


00:24:33.700 --> 00:24:36.880 align:middle line:84%
So try your code
for the next couple

00:24:36.880 --> 00:24:38.588 align:middle line:90%
of minutes around line 50.

00:24:38.588 --> 00:24:40.005 align:middle line:84%
And then we can
write it together.

00:24:40.005 --> 00:24:42.790 align:middle line:90%


00:24:42.790 --> 00:24:45.100 align:middle line:90%
All right.

00:24:45.100 --> 00:24:46.140 align:middle line:90%
How can we start?

00:24:46.140 --> 00:24:56.960 align:middle line:90%


00:24:56.960 --> 00:24:59.036 align:middle line:90%
Yes.

00:24:59.036 --> 00:25:00.307 align:middle line:90%
STUDENT: I created a new list.

00:25:00.307 --> 00:25:00.890 align:middle line:90%
ANA BELL: Yep.

00:25:00.890 --> 00:25:01.950 align:middle line:90%
What did you name it?

00:25:01.950 --> 00:25:02.810 align:middle line:90%
STUDENT: [INAUDIBLE]

00:25:02.810 --> 00:25:03.435 align:middle line:90%
ANA BELL: Cool.

00:25:03.435 --> 00:25:06.000 align:middle line:90%


00:25:06.000 --> 00:25:08.330 align:middle line:90%
What did you make it be--

00:25:08.330 --> 00:25:08.990 align:middle line:90%
empty list.

00:25:08.990 --> 00:25:10.913 align:middle line:90%
OK.

00:25:10.913 --> 00:25:15.330 align:middle line:84%
STUDENT: And then
I said [INAUDIBLE]..

00:25:15.330 --> 00:25:15.930 align:middle line:90%
ANA BELL: Yep.

00:25:15.930 --> 00:25:19.870 align:middle line:84%
So for I in L.
And at this point,

00:25:19.870 --> 00:25:22.320 align:middle line:84%
I would make a note for
myself, because you use I,

00:25:22.320 --> 00:25:25.870 align:middle line:90%
which in my brain means index.

00:25:25.870 --> 00:25:27.390 align:middle line:84%
But I would make
a note for myself

00:25:27.390 --> 00:25:31.980 align:middle line:84%
that I is maybe 1,
then 2, then 2, then 2,

00:25:31.980 --> 00:25:34.560 align:middle line:84%
just according to
this first example.

00:25:34.560 --> 00:25:38.100 align:middle line:84%
So if I'm reading the
code, I would just--

00:25:38.100 --> 00:25:41.020 align:middle line:84%
I will remember that it's
not the index, but go on.

00:25:41.020 --> 00:25:43.570 align:middle line:90%
So for I and L directly.

00:25:43.570 --> 00:25:46.450 align:middle line:90%
STUDENT: [INAUDIBLE]

00:25:46.450 --> 00:25:49.990 align:middle line:90%


00:25:49.990 --> 00:25:53.080 align:middle line:90%
ANA BELL: Like this?

00:25:53.080 --> 00:25:55.024 align:middle line:90%
OK.

00:25:55.024 --> 00:25:57.270 align:middle line:90%
STUDENT: [INAUDIBLE]

00:25:57.270 --> 00:26:00.380 align:middle line:90%


00:26:00.380 --> 00:26:02.220 align:middle line:90%
ANA BELL: Yeah.

00:26:02.220 --> 00:26:03.090 align:middle line:90%
OK.

00:26:03.090 --> 00:26:06.120 align:middle line:90%
And then that's good.

00:26:06.120 --> 00:26:08.120 align:middle line:90%
Return your list.

00:26:08.120 --> 00:26:09.530 align:middle line:90%
OK.

00:26:09.530 --> 00:26:10.720 align:middle line:90%
Let's try it.

00:26:10.720 --> 00:26:15.220 align:middle line:90%


00:26:15.220 --> 00:26:16.972 align:middle line:90%
STUDENT: [INAUDIBLE]

00:26:16.972 --> 00:26:18.850 align:middle line:84%
ANA BELL: Yeah, so
e is not a list.

00:26:18.850 --> 00:26:23.340 align:middle line:90%
e is going to be an element.

00:26:23.340 --> 00:26:25.320 align:middle line:90%
So that's my bad.

00:26:25.320 --> 00:26:33.680 align:middle line:84%
I should have put this in here.
e is an object or something.

00:26:33.680 --> 00:26:36.170 align:middle line:84%
It could be a list,
but then I would

00:26:36.170 --> 00:26:39.320 align:middle line:84%
be looking for that exact
sublist, that exact list

00:26:39.320 --> 00:26:40.230 align:middle line:90%
as a subelement.

00:26:40.230 --> 00:26:42.800 align:middle line:84%
So maybe we think of
e as an object like 5

00:26:42.800 --> 00:26:44.960 align:middle line:90%
or something like that.

00:26:44.960 --> 00:26:46.800 align:middle line:90%
STUDENT: [INAUDIBLE]

00:26:46.800 --> 00:26:47.900 align:middle line:90%
ANA BELL: Yeah.

00:26:47.900 --> 00:26:49.320 align:middle line:90%
Not equal to e.

00:26:49.320 --> 00:26:51.840 align:middle line:90%


00:26:51.840 --> 00:26:55.230 align:middle line:84%
So if I'm just looking
for that element directly,

00:26:55.230 --> 00:26:58.650 align:middle line:84%
I want I to be not equal
to e, in which case

00:26:58.650 --> 00:27:00.820 align:middle line:84%
I keep the element
in my new list.

00:27:00.820 --> 00:27:05.970 align:middle line:84%
So if we run that, that
gives me 1 according to this.

00:27:05.970 --> 00:27:07.330 align:middle line:90%
Looks like it's correct.

00:27:07.330 --> 00:27:10.750 align:middle line:84%
And then we can run it
with these other two cases.

00:27:10.750 --> 00:27:13.870 align:middle line:84%
So here I'm removing
the element 1.

00:27:13.870 --> 00:27:17.700 align:middle line:84%
So I'm going to keep 2,
2, 2 as my returned list.

00:27:17.700 --> 00:27:22.180 align:middle line:84%
And here I'm removing 0, which
doesn't exist in my list at all.

00:27:22.180 --> 00:27:24.150 align:middle line:84%
So it should just
keep, and it does,

00:27:24.150 --> 00:27:26.890 align:middle line:90%
my original list unchanged.

00:27:26.890 --> 00:27:29.610 align:middle line:90%


00:27:29.610 --> 00:27:31.750 align:middle line:84%
Any questions
about this example?

00:27:31.750 --> 00:27:33.170 align:middle line:90%
Anyone try it a different way?

00:27:33.170 --> 00:27:38.300 align:middle line:90%


00:27:38.300 --> 00:27:38.800 align:middle line:90%
OK.

00:27:38.800 --> 00:27:44.860 align:middle line:90%


00:27:44.860 --> 00:27:45.360 align:middle line:90%
All right.

00:27:45.360 --> 00:27:47.480 align:middle line:90%
So other useful list operations.

00:27:47.480 --> 00:27:52.910 align:middle line:84%
We can convert strings to lists
and then lists back to strings.

00:27:52.910 --> 00:27:56.660 align:middle line:84%
And this is very
useful when you're

00:27:56.660 --> 00:27:59.910 align:middle line:84%
reading in text or something
like that to a function.

00:27:59.910 --> 00:28:03.090 align:middle line:84%
It's going to be useful for
problem set 3, so on and so on.

00:28:03.090 --> 00:28:06.800 align:middle line:84%
So let's first see how
we can take a string s

00:28:06.800 --> 00:28:08.340 align:middle line:90%
and convert it to a list.

00:28:08.340 --> 00:28:12.440 align:middle line:84%
So if we just cast
s to a list, the way

00:28:12.440 --> 00:28:15.890 align:middle line:84%
we used to cast the
number 5 to a float,

00:28:15.890 --> 00:28:18.110 align:middle line:84%
we would just say
float parentheses 5.

00:28:18.110 --> 00:28:20.840 align:middle line:84%
Well, we can take a list
and cast it to a list

00:28:20.840 --> 00:28:23.690 align:middle line:90%
by saying list parentheses s.

00:28:23.690 --> 00:28:26.810 align:middle line:84%
And if we cast it
like this, Python

00:28:26.810 --> 00:28:29.360 align:middle line:84%
takes every single
character in s

00:28:29.360 --> 00:28:32.580 align:middle line:84%
and makes it be a separate
element in a list.

00:28:32.580 --> 00:28:36.120 align:middle line:84%
So you can see here I've got
the string I heart cs &u.

00:28:36.120 --> 00:28:39.350 align:middle line:84%
It makes for me a list where
every single character,

00:28:39.350 --> 00:28:42.080 align:middle line:84%
including the space and
all the special characters,

00:28:42.080 --> 00:28:46.400 align:middle line:84%
becomes a separate
entry in my list.

00:28:46.400 --> 00:28:47.900 align:middle line:90%
That's not that useful.

00:28:47.900 --> 00:28:50.340 align:middle line:84%
I mean, it can be, but
it's not that useful.

00:28:50.340 --> 00:28:53.870 align:middle line:84%
What is more useful is
to take an input string

00:28:53.870 --> 00:28:56.790 align:middle line:84%
and split it on a
particular character.

00:28:56.790 --> 00:28:59.630 align:middle line:84%
So one very common character
that we would split on

00:28:59.630 --> 00:29:00.480 align:middle line:90%
is the space.

00:29:00.480 --> 00:29:02.090 align:middle line:84%
And if we do
something like that,

00:29:02.090 --> 00:29:05.180 align:middle line:84%
it basically extracts
from us, from our string

00:29:05.180 --> 00:29:09.200 align:middle line:84%
all of the individual words,
which is pretty useful.

00:29:09.200 --> 00:29:12.860 align:middle line:90%
So here I've got s.split.

00:29:12.860 --> 00:29:16.560 align:middle line:84%
And in parentheses, I've got the
character I want to split on.

00:29:16.560 --> 00:29:18.570 align:middle line:84%
In this particular
case, a space.

00:29:18.570 --> 00:29:20.825 align:middle line:84%
So if I take s and I
split on the space,

00:29:20.825 --> 00:29:22.700 align:middle line:84%
Python will go from the
beginning of the list

00:29:22.700 --> 00:29:23.940 align:middle line:90%
to the first space.

00:29:23.940 --> 00:29:27.200 align:middle line:84%
Make that be one
element in the list.

00:29:27.200 --> 00:29:30.380 align:middle line:84%
It'll go from the first space
to the next space in my string

00:29:30.380 --> 00:29:32.595 align:middle line:84%
and make that be the
next element in the list.

00:29:32.595 --> 00:29:34.970 align:middle line:84%
And so on and so on, until it
gets to the end of the list

00:29:34.970 --> 00:29:38.730 align:middle line:84%
and makes that last bit the
last element in my list.

00:29:38.730 --> 00:29:44.630 align:middle line:84%
So here, when I've split on the
space, I've got 3 base words,

00:29:44.630 --> 00:29:46.650 align:middle line:90%
quote unquote "words."

00:29:46.650 --> 00:29:48.910 align:middle line:90%
I heart is going to be one.

00:29:48.910 --> 00:29:51.010 align:middle line:84%
And there it is
as my first entry.

00:29:51.010 --> 00:29:55.090 align:middle line:84%
CS is in between these two
spaces and that's my next entry.

00:29:55.090 --> 00:29:56.520 align:middle line:90%
And, &u?

00:29:56.520 --> 00:29:58.650 align:middle line:90%
Is my last entry here.

00:29:58.650 --> 00:30:01.170 align:middle line:84%
So this is a very
useful function.

00:30:01.170 --> 00:30:03.900 align:middle line:84%
We can, of course, split
on any character we'd like.

00:30:03.900 --> 00:30:06.940 align:middle line:84%
So here I am, splitting on
the less than character.

00:30:06.940 --> 00:30:08.252 align:middle line:90%
So there's only one.

00:30:08.252 --> 00:30:09.960 align:middle line:84%
So if I split on the
less than character,

00:30:09.960 --> 00:30:14.220 align:middle line:84%
one element in my resulting
list is just the capital I.

00:30:14.220 --> 00:30:19.110 align:middle line:84%
And the remaining element in my
resulting list is the 3 space cs

00:30:19.110 --> 00:30:19.650 align:middle line:90%
&u.

00:30:19.650 --> 00:30:20.817 align:middle line:90%
And there it is right there.

00:30:20.817 --> 00:30:25.030 align:middle line:90%


00:30:25.030 --> 00:30:25.610 align:middle line:90%
All right.

00:30:25.610 --> 00:30:30.710 align:middle line:84%
So once we have a list,
we can also go backward.

00:30:30.710 --> 00:30:33.560 align:middle line:84%
We can take this list and
convert it back to strings.

00:30:33.560 --> 00:30:38.600 align:middle line:84%
So we use this
join function here.

00:30:38.600 --> 00:30:40.150 align:middle line:84%
And the thing before
the dot is going

00:30:40.150 --> 00:30:44.230 align:middle line:84%
to be what character you want
to join the list elements with.

00:30:44.230 --> 00:30:48.440 align:middle line:84%
And this is the list you want
to join back into a string.

00:30:48.440 --> 00:30:50.030 align:middle line:90%
So let's look at an example.

00:30:50.030 --> 00:30:53.530 align:middle line:84%
So let's say I have list L
that has three entries in it,

00:30:53.530 --> 00:31:00.330 align:middle line:84%
A, B, and C. If I join
on the empty string,

00:31:00.330 --> 00:31:03.180 align:middle line:84%
so here this is just quote
quote beside each other.

00:31:03.180 --> 00:31:04.910 align:middle line:84%
There's no space or
anything in there.

00:31:04.910 --> 00:31:08.390 align:middle line:84%
That's going to take from me
all the elements in the list L

00:31:08.390 --> 00:31:10.310 align:middle line:90%
and join them together as one.

00:31:10.310 --> 00:31:13.280 align:middle line:84%
Nothing in between
the A, B, and C.

00:31:13.280 --> 00:31:16.700 align:middle line:84%
And this operation here
will basically make for me

00:31:16.700 --> 00:31:20.490 align:middle line:90%
A, B, the string A, B, C.

00:31:20.490 --> 00:31:23.690 align:middle line:84%
If I join on an underscore,
you might have guessed,

00:31:23.690 --> 00:31:26.720 align:middle line:84%
it'll join A, B, and
C with an underscore

00:31:26.720 --> 00:31:27.960 align:middle line:90%
in between each character.

00:31:27.960 --> 00:31:28.650 align:middle line:90%
So there it is.

00:31:28.650 --> 00:31:30.470 align:middle line:90%
A_B_C.

00:31:30.470 --> 00:31:33.413 align:middle line:84%
You can join on any
character you'd like.

00:31:33.413 --> 00:31:35.580 align:middle line:84%
I don't know if you can
join on multiple characters,

00:31:35.580 --> 00:31:36.840 align:middle line:90%
but I don't see why not.

00:31:36.840 --> 00:31:39.660 align:middle line:84%
You could try this
out on your own.

00:31:39.660 --> 00:31:45.310 align:middle line:84%
Join only works with lists that
contain only string elements.

00:31:45.310 --> 00:31:50.490 align:middle line:84%
So if we try to join a list
that has just integers or floats

00:31:50.490 --> 00:31:53.670 align:middle line:84%
or Booleans, anything that
doesn't contain a string in it,

00:31:53.670 --> 00:31:56.523 align:middle line:90%
then you will get an error.

00:31:56.523 --> 00:31:58.440 align:middle line:84%
Because it's basically
trying to put all these

00:31:58.440 --> 00:31:59.680 align:middle line:90%
back into a big string.

00:31:59.680 --> 00:32:02.730 align:middle line:84%
If you wanted to join
non-string elements,

00:32:02.730 --> 00:32:06.060 align:middle line:84%
you would have to basically
loop through and cast

00:32:06.060 --> 00:32:08.340 align:middle line:84%
every one of these to
a string first and then

00:32:08.340 --> 00:32:09.570 align:middle line:90%
join them together.

00:32:09.570 --> 00:32:12.570 align:middle line:84%
So if you want to join 1, 2,
3, you would have cast them

00:32:12.570 --> 00:32:16.770 align:middle line:84%
to strings and then you could
join them to make the string 1,

00:32:16.770 --> 00:32:19.120 align:middle line:90%
2, 3.

00:32:19.120 --> 00:32:22.070 align:middle line:84%
OK, so let's have you
work on this example.

00:32:22.070 --> 00:32:27.770 align:middle line:84%
So here we're going to
try to split the input.

00:32:27.770 --> 00:32:29.960 align:middle line:84%
So here is a function
called count words.

00:32:29.960 --> 00:32:32.800 align:middle line:84%
It takes in one input
sen for sentence.

00:32:32.800 --> 00:32:34.900 align:middle line:84%
And I wanted to use
something that's

00:32:34.900 --> 00:32:38.440 align:middle line:84%
not s just to make it clear
that the thing before the dot

00:32:38.440 --> 00:32:39.730 align:middle line:90%
isn't always s.

00:32:39.730 --> 00:32:44.080 align:middle line:84%
It's whatever object you want
to split or join or whatever.

00:32:44.080 --> 00:32:49.330 align:middle line:84%
So this function is going to
return how many words are in s.

00:32:49.330 --> 00:32:51.080 align:middle line:84%
Quote unquote
"words" in this case,

00:32:51.080 --> 00:32:56.200 align:middle line:84%
because I'm just interested in
the elements or the characters

00:32:56.200 --> 00:32:59.790 align:middle line:84%
between spaces and between the
start and the end of a word.

00:32:59.790 --> 00:33:02.540 align:middle line:84%
So if it's a number, I
still count that as a word.

00:33:02.540 --> 00:33:04.900 align:middle line:84%
If it's a special character,
a dot, exclamation point,

00:33:04.900 --> 00:33:08.050 align:middle line:84%
I would still count
that as a word as well.

00:33:08.050 --> 00:33:14.833 align:middle line:84%
So this should be just a couple
of lines of code down around 99.

00:33:14.833 --> 00:33:16.750 align:middle line:84%
So I'll give you about
a minute to work on it,

00:33:16.750 --> 00:33:19.912 align:middle line:84%
and then we can
write it together.

00:33:19.912 --> 00:33:21.750 align:middle line:84%
So thoughts on how
we can do this?

00:33:21.750 --> 00:33:28.670 align:middle line:90%


00:33:28.670 --> 00:33:30.085 align:middle line:90%
L1 equals sen.split.

00:33:30.085 --> 00:33:33.400 align:middle line:90%


00:33:33.400 --> 00:33:33.900 align:middle line:90%
Yep.

00:33:33.900 --> 00:33:36.310 align:middle line:90%
Sorry, parentheses, space.

00:33:36.310 --> 00:33:37.170 align:middle line:90%
Yep.

00:33:37.170 --> 00:33:39.840 align:middle line:90%
STUDENT: [INAUDIBLE]

00:33:39.840 --> 00:33:40.920 align:middle line:90%
ANA BELL: Yep.

00:33:40.920 --> 00:33:42.910 align:middle line:84%
And then we can return
the length of L1.

00:33:42.910 --> 00:33:44.550 align:middle line:90%
Perfect.

00:33:44.550 --> 00:33:47.190 align:middle line:84%
Let's run it on
these two examples.

00:33:47.190 --> 00:33:49.150 align:middle line:90%
And should print 3 and 12.

00:33:49.150 --> 00:33:50.190 align:middle line:90%
And it does.

00:33:50.190 --> 00:33:53.640 align:middle line:84%
So notice how easy
this was with lists,

00:33:53.640 --> 00:33:56.880 align:middle line:84%
because lists are data structure
that's just kind of naturally

00:33:56.880 --> 00:33:57.820 align:middle line:90%
iterative.

00:33:57.820 --> 00:34:01.500 align:middle line:84%
And so running len on this
split list or split string,

00:34:01.500 --> 00:34:04.630 align:middle line:84%
which gave us a
list, is really easy.

00:34:04.630 --> 00:34:06.090 align:middle line:90%
It's a two line piece of code.

00:34:06.090 --> 00:34:09.900 align:middle line:84%
Without lists, you could
imagine creating variables

00:34:09.900 --> 00:34:13.090 align:middle line:84%
that keep track of where
you see the first space

00:34:13.090 --> 00:34:15.460 align:middle line:84%
and then iterating through
one character at a time.

00:34:15.460 --> 00:34:18.510 align:middle line:84%
And if it's a space, keep track
of the fact that you saw a space

00:34:18.510 --> 00:34:22.139 align:middle line:84%
and then look for the next
space and then resetting things

00:34:22.139 --> 00:34:23.710 align:middle line:90%
every time you see a space.

00:34:23.710 --> 00:34:26.409 align:middle line:84%
And that would be
really, really tedious.

00:34:26.409 --> 00:34:29.010 align:middle line:84%
It would be a really
good quiz one question,

00:34:29.010 --> 00:34:31.409 align:middle line:84%
but not once we've
introduced lists,

00:34:31.409 --> 00:34:34.625 align:middle line:84%
because it becomes really,
really easy to do it with lists.

00:34:34.625 --> 00:34:39.560 align:middle line:90%


00:34:39.560 --> 00:34:41.420 align:middle line:90%
All right.

00:34:41.420 --> 00:34:45.260 align:middle line:84%
So now that we
have lists, we can

00:34:45.260 --> 00:34:48.739 align:middle line:84%
do other really interesting
and useful operations

00:34:48.739 --> 00:34:50.290 align:middle line:90%
to mutate the list.

00:34:50.290 --> 00:34:55.889 align:middle line:84%
So we saw the dot notation
on a list to do append.

00:34:55.889 --> 00:34:58.760 align:middle line:84%
So basically, to add an
item to the end of our list.

00:34:58.760 --> 00:35:00.420 align:middle line:90%
That was useful.

00:35:00.420 --> 00:35:03.440 align:middle line:84%
Other things we can do in
terms of mutating the list

00:35:03.440 --> 00:35:06.480 align:middle line:84%
is to sort a list
and reverse a list.

00:35:06.480 --> 00:35:10.840 align:middle line:84%
And these are also very
useful operations on lists.

00:35:10.840 --> 00:35:14.420 align:middle line:84%
So the first two here,
sort and reverse,

00:35:14.420 --> 00:35:18.140 align:middle line:84%
is the notation for
how we sort a list

00:35:18.140 --> 00:35:19.780 align:middle line:90%
and how we reverse a list.

00:35:19.780 --> 00:35:24.500 align:middle line:84%
And these will mutate the list
that you call the functions on.

00:35:24.500 --> 00:35:27.650 align:middle line:84%
So if I have list
4, 2, 7 here and I

00:35:27.650 --> 00:35:33.510 align:middle line:84%
call L.sort and I print L
as the next line after this,

00:35:33.510 --> 00:35:39.580 align:middle line:84%
L will have changed in memory
to be 2, 4, and 7 in that order.

00:35:39.580 --> 00:35:41.290 align:middle line:90%
It didn't make a copy for me.

00:35:41.290 --> 00:35:43.130 align:middle line:84%
It didn't preserve
the original order.

00:35:43.130 --> 00:35:47.940 align:middle line:84%
It changed that list to
be now in sorted order.

00:35:47.940 --> 00:35:49.480 align:middle line:90%
Reverse similarly.

00:35:49.480 --> 00:35:52.110 align:middle line:84%
So if we do
L.reverse on 4, 2, 7,

00:35:52.110 --> 00:35:53.710 align:middle line:84%
it will reverse
all the elements.

00:35:53.710 --> 00:35:56.200 align:middle line:84%
So the one at the end
becomes at the beginning.

00:35:56.200 --> 00:35:58.240 align:middle line:84%
The one second last
is the second one.

00:35:58.240 --> 00:36:00.810 align:middle line:84%
Third last is the third
element in the list, and so on.

00:36:00.810 --> 00:36:03.430 align:middle line:90%
And again, this mutates my list.

00:36:03.430 --> 00:36:05.640 align:middle line:84%
So I would have lost
my original order

00:36:05.640 --> 00:36:11.050 align:middle line:84%
with this command, L.reverse
and with L.sort, of course.

00:36:11.050 --> 00:36:14.140 align:middle line:84%
Now, there are many
situations where you want

00:36:14.140 --> 00:36:17.353 align:middle line:90%
to preserve the original order.

00:36:17.353 --> 00:36:19.270 align:middle line:84%
I don't know, maybe like
the order that people

00:36:19.270 --> 00:36:22.618 align:middle line:84%
join a company or the order that
people joined a grocery queue.

00:36:22.618 --> 00:36:23.910 align:middle line:90%
I don't know, things like that.

00:36:23.910 --> 00:36:25.990 align:middle line:84%
You might want to preserve
that original order,

00:36:25.990 --> 00:36:30.370 align:middle line:84%
but you might also get maybe
the sorted names of people

00:36:30.370 --> 00:36:32.290 align:middle line:84%
for a function
that does something

00:36:32.290 --> 00:36:34.060 align:middle line:90%
with those sorted names.

00:36:34.060 --> 00:36:39.190 align:middle line:84%
In that case, you don't want to
call sort on your original list,

00:36:39.190 --> 00:36:41.420 align:middle line:84%
because you would lose
the original order.

00:36:41.420 --> 00:36:42.910 align:middle line:84%
You could, of
course, make a copy

00:36:42.910 --> 00:36:47.930 align:middle line:84%
or you could call
this sorted function.

00:36:47.930 --> 00:36:50.300 align:middle line:84%
And the sorted function
is going to keep

00:36:50.300 --> 00:36:53.510 align:middle line:84%
my original list L
intact in the same order

00:36:53.510 --> 00:36:55.700 align:middle line:90%
that I had created it in.

00:36:55.700 --> 00:36:59.720 align:middle line:84%
But it would return for me,
so this function will actually

00:36:59.720 --> 00:37:04.640 align:middle line:84%
make a copy and return for
me the sorted version of L.

00:37:04.640 --> 00:37:06.570 align:middle line:90%
And L remains unchanged.

00:37:06.570 --> 00:37:08.790 align:middle line:84%
So this function does
not do any mutation.

00:37:08.790 --> 00:37:12.660 align:middle line:84%
We have to take the return and
save it into a new variable.

00:37:12.660 --> 00:37:14.720 align:middle line:90%
This case I called it L new.

00:37:14.720 --> 00:37:19.750 align:middle line:84%
So might be a little
bit sort of hard to keep

00:37:19.750 --> 00:37:23.150 align:middle line:84%
straight in your mind,
whether to use sort or sorted.

00:37:23.150 --> 00:37:25.570 align:middle line:84%
You could, of course,
always try it in the console

00:37:25.570 --> 00:37:27.950 align:middle line:90%
to see which one does what.

00:37:27.950 --> 00:37:30.160 align:middle line:84%
The way I remember
and think about it

00:37:30.160 --> 00:37:33.230 align:middle line:84%
is the sort to me
feels like a command.

00:37:33.230 --> 00:37:36.110 align:middle line:90%
It's like sort this list.

00:37:36.110 --> 00:37:37.970 align:middle line:90%
Mutate this list and sort it.

00:37:37.970 --> 00:37:42.390 align:middle line:84%
Whereas sorted is
more of a request.

00:37:42.390 --> 00:37:45.330 align:middle line:84%
Can you please get me
the sorted version of L?

00:37:45.330 --> 00:37:49.110 align:middle line:84%
And so that's kind of how
I keep things in my mind

00:37:49.110 --> 00:37:52.080 align:middle line:84%
as to whether I'm calling
sort to do the mutation

00:37:52.080 --> 00:37:55.680 align:middle line:84%
or asking to get the
sorted version of the list.

00:37:55.680 --> 00:37:57.080 align:middle line:90%
Yes?

00:37:57.080 --> 00:37:58.730 align:middle line:90%
STUDENT: What is it sorting by?

00:37:58.730 --> 00:38:00.950 align:middle line:84%
ANA BELL: It is
sorting it by whatever

00:38:00.950 --> 00:38:05.670 align:middle line:84%
the built in sort is for
those particular object types.

00:38:05.670 --> 00:38:09.720 align:middle line:84%
So in the case of integers,
it's just increasing order.

00:38:09.720 --> 00:38:14.990 align:middle line:84%
In the case of strings,
it'll be alphabetical.

00:38:14.990 --> 00:38:18.290 align:middle line:84%
You can choose different
sorting functions,

00:38:18.290 --> 00:38:20.280 align:middle line:90%
but we don't get into that.

00:38:20.280 --> 00:38:21.110 align:middle line:90%
Yeah.

00:38:21.110 --> 00:38:23.510 align:middle line:90%
STUDENT: [INAUDIBLE]

00:38:23.510 --> 00:38:25.140 align:middle line:84%
ANA BELL: That's
a good question.

00:38:25.140 --> 00:38:28.860 align:middle line:84%
I think they do in
order for it to work.

00:38:28.860 --> 00:38:34.520 align:middle line:84%
So we can try L equals 1
and then we can give it

00:38:34.520 --> 00:38:36.410 align:middle line:90%
a tuple or something.

00:38:36.410 --> 00:38:39.700 align:middle line:84%
And then we can
ask sort L. Yeah.

00:38:39.700 --> 00:38:42.560 align:middle line:84%
So in this case, it doesn't
know how to resolve.

00:38:42.560 --> 00:38:44.470 align:middle line:84%
It's trying to do
a behind the scenes

00:38:44.470 --> 00:38:47.210 align:middle line:84%
less than to figure out which
one is bigger than which.

00:38:47.210 --> 00:38:50.080 align:middle line:84%
And in this case, it
doesn't know how to resolve.

00:38:50.080 --> 00:38:52.930 align:middle line:84%
How do you choose whether the
tuple is bigger than an integer?

00:38:52.930 --> 00:38:54.722 align:middle line:84%
But you can imagine,
again, as I mentioned,

00:38:54.722 --> 00:38:57.431 align:middle line:84%
this is not something we do, but
you could write your own sorting

00:38:57.431 --> 00:38:59.260 align:middle line:84%
function where
depending on the type,

00:38:59.260 --> 00:39:02.235 align:middle line:84%
you would decide
which one is bigger.

00:39:02.235 --> 00:39:05.770 align:middle line:90%


00:39:05.770 --> 00:39:07.430 align:middle line:90%
So yes.

00:39:07.430 --> 00:39:08.335 align:middle line:90%
Question?

00:39:08.335 --> 00:39:10.210 align:middle line:90%
STUDENT: [INAUDIBLE]

00:39:10.210 --> 00:39:13.750 align:middle line:90%


00:39:13.750 --> 00:39:16.210 align:middle line:84%
ANA BELL: So you would just
do L.sort without parentheses,

00:39:16.210 --> 00:39:18.940 align:middle line:84%
but L has to be a
list that contains

00:39:18.940 --> 00:39:20.260 align:middle line:90%
things that can't be sorted.

00:39:20.260 --> 00:39:24.120 align:middle line:84%
So all integers, all strings,
or something like that.

00:39:24.120 --> 00:39:27.540 align:middle line:84%
So let's look at the memory
diagram for how this would look,

00:39:27.540 --> 00:39:30.870 align:middle line:84%
just to bring the point
home about objects

00:39:30.870 --> 00:39:32.050 align:middle line:90%
that are being mutated.

00:39:32.050 --> 00:39:35.680 align:middle line:90%
So our original L is 9, 6, 0, 3.

00:39:35.680 --> 00:39:40.050 align:middle line:84%
So in memory, I've got the
name L bound to 9, 6, 0, 3.

00:39:40.050 --> 00:39:43.050 align:middle line:84%
Again, let's do an
append just for fun.

00:39:43.050 --> 00:39:47.280 align:middle line:84%
L.append 5 is going to add
a 5 to the end of that list.

00:39:47.280 --> 00:39:49.470 align:middle line:84%
And append, sort,
and reverse will all

00:39:49.470 --> 00:39:50.875 align:middle line:90%
be used for a side effect.

00:39:50.875 --> 00:39:52.500 align:middle line:84%
That means they're
going to be mutating

00:39:52.500 --> 00:39:57.270 align:middle line:84%
the object, whereas sorted
will not do a mutation.

00:39:57.270 --> 00:39:59.550 align:middle line:84%
So let's do an
append to the end.

00:39:59.550 --> 00:40:02.640 align:middle line:84%
That's going to put a 5
at the end of the list.

00:40:02.640 --> 00:40:05.940 align:middle line:84%
Something we already
know how it works.

00:40:05.940 --> 00:40:12.070 align:middle line:84%
Now let's do A equals sorted
L. So again, it's an equality.

00:40:12.070 --> 00:40:13.830 align:middle line:84%
So the thing on
the right hand side

00:40:13.830 --> 00:40:16.350 align:middle line:84%
is going to be the
function that returns

00:40:16.350 --> 00:40:18.390 align:middle line:84%
for me the sorted
version of L. So it's

00:40:18.390 --> 00:40:20.080 align:middle line:90%
going to create a new object.

00:40:20.080 --> 00:40:22.350 align:middle line:84%
However it does the
sort, it's going

00:40:22.350 --> 00:40:26.320 align:middle line:84%
to create for me a new list
that contains that sorted order.

00:40:26.320 --> 00:40:30.250 align:middle line:84%
The original L notice in
memory remains unchanged.

00:40:30.250 --> 00:40:33.720 align:middle line:84%
So if I want to reference L in
my program from here on out,

00:40:33.720 --> 00:40:39.770 align:middle line:84%
it will use this unchanged L.
So now the return of sorted

00:40:39.770 --> 00:40:43.910 align:middle line:84%
is this list and I bind
it to A. So name A now

00:40:43.910 --> 00:40:47.590 align:middle line:84%
points to the
sorted list version.

00:40:47.590 --> 00:40:48.090 align:middle line:90%
All right.

00:40:48.090 --> 00:40:53.470 align:middle line:84%
Now, what if I do this
line here, B equals L.sort.

00:40:53.470 --> 00:40:55.630 align:middle line:84%
Again, let's look at
the right hand side.

00:40:55.630 --> 00:41:03.050 align:middle line:84%
L.sort is going to mutate L.
So this function itself will go

00:41:03.050 --> 00:41:06.200 align:middle line:90%
and change L to be--

00:41:06.200 --> 00:41:07.880 align:middle line:84%
L's object, the
object that L points

00:41:07.880 --> 00:41:11.580 align:middle line:90%
to, to be the sorted list.

00:41:11.580 --> 00:41:13.260 align:middle line:90%
But it's not done.

00:41:13.260 --> 00:41:15.550 align:middle line:84%
This function is being
used for a side effect.

00:41:15.550 --> 00:41:18.620 align:middle line:90%
So what is the return from it?

00:41:18.620 --> 00:41:19.470 align:middle line:90%
None, right?

00:41:19.470 --> 00:41:20.640 align:middle line:90%
It's like the append.

00:41:20.640 --> 00:41:23.630 align:middle line:84%
So this example here
will make B point

00:41:23.630 --> 00:41:26.620 align:middle line:84%
to the return of that
function, which is just none.

00:41:26.620 --> 00:41:31.640 align:middle line:90%


00:41:31.640 --> 00:41:34.010 align:middle line:90%
Now, please don't ever do this.

00:41:34.010 --> 00:41:38.310 align:middle line:84%
All you would have to do to sort
L is to just on a line by itself

00:41:38.310 --> 00:41:39.270 align:middle line:90%
say L.sort.

00:41:39.270 --> 00:41:41.510 align:middle line:84%
I just did this
to show you again

00:41:41.510 --> 00:41:45.350 align:middle line:84%
that if you do L equals
L.sort, bad things will happen.

00:41:45.350 --> 00:41:47.903 align:middle line:84%
You're going to
reassign L to be none.

00:41:47.903 --> 00:41:50.070 align:middle line:84%
In this case, I saved it
under a different variable,

00:41:50.070 --> 00:41:52.630 align:middle line:84%
but it's an easy
mistake to make.

00:41:52.630 --> 00:41:55.370 align:middle line:90%


00:41:55.370 --> 00:41:57.740 align:middle line:84%
And then what about
the last one here?

00:41:57.740 --> 00:41:58.700 align:middle line:90%
L.reverse.

00:41:58.700 --> 00:42:02.330 align:middle line:84%
Again, I'm going to go and grab
the object pointed to by L,

00:42:02.330 --> 00:42:04.140 align:middle line:84%
and I'm going to reverse
all the elements.

00:42:04.140 --> 00:42:08.390 align:middle line:84%
So here doing L.sort and then
L.reverse right afterward

00:42:08.390 --> 00:42:12.180 align:middle line:84%
makes my list be in
reverse sorted order.

00:42:12.180 --> 00:42:14.190 align:middle line:84%
So biggest number
to smallest number.

00:42:14.190 --> 00:42:18.161 align:middle line:84%
So with that command
there, I've got 9, 6, 5, 3,

00:42:18.161 --> 00:42:22.090 align:middle line:90%
0 instead of 0, 3, 5, 6, 9.

00:42:22.090 --> 00:42:26.420 align:middle line:84%
And again, sort and reverse
changed my list L directly.

00:42:26.420 --> 00:42:30.550 align:middle line:84%
So I've lost that initial
order of 9, 6, 0, 3

00:42:30.550 --> 00:42:31.755 align:middle line:90%
that I had up here.

00:42:31.755 --> 00:42:36.030 align:middle line:90%


00:42:36.030 --> 00:42:38.160 align:middle line:90%
One last point I want to make.

00:42:38.160 --> 00:42:39.840 align:middle line:84%
I know we've usually
seen functions

00:42:39.840 --> 00:42:41.120 align:middle line:90%
that take in parameters.

00:42:41.120 --> 00:42:44.730 align:middle line:84%
Sort and reverse
are still functions.

00:42:44.730 --> 00:42:48.670 align:middle line:84%
And they just happen to
not need any parameters.

00:42:48.670 --> 00:42:52.330 align:middle line:84%
You call them on the object
L using this dot notation.

00:42:52.330 --> 00:42:55.680 align:middle line:84%
So in effect, it does have sort
of a quote unquote "parameter,"

00:42:55.680 --> 00:42:57.120 align:middle line:90%
the thing before the dot.

00:42:57.120 --> 00:42:59.280 align:middle line:84%
But it doesn't
take anything else

00:42:59.280 --> 00:43:01.780 align:middle line:84%
in their own
respective parentheses.

00:43:01.780 --> 00:43:04.200 align:middle line:84%
But they do still need
the parentheses there,

00:43:04.200 --> 00:43:05.740 align:middle line:90%
because they are functions.

00:43:05.740 --> 00:43:11.130 align:middle line:84%
They are operations that
will do something for us.

00:43:11.130 --> 00:43:12.670 align:middle line:90%
Questions about this?

00:43:12.670 --> 00:43:15.130 align:middle line:90%
Is it OK?

00:43:15.130 --> 00:43:18.770 align:middle line:84%
OK, very good, because now you
get a chance to try it out.

00:43:18.770 --> 00:43:21.340 align:middle line:84%
So let's have you do
something similar to what

00:43:21.340 --> 00:43:22.610 align:middle line:90%
we did last time.

00:43:22.610 --> 00:43:25.510 align:middle line:84%
Take in a parameter sen,
which is a string representing

00:43:25.510 --> 00:43:26.480 align:middle line:90%
a sentence.

00:43:26.480 --> 00:43:29.830 align:middle line:84%
I want you to figure out all
the words, quote unquote,

00:43:29.830 --> 00:43:34.040 align:middle line:84%
in the same manner that we did
before in the previous example,

00:43:34.040 --> 00:43:36.760 align:middle line:84%
but now return for me
a list with these words

00:43:36.760 --> 00:43:39.550 align:middle line:90%
in sorted order.

00:43:39.550 --> 00:43:44.110 align:middle line:84%
So if the input was look at
this photograph as my sentence,

00:43:44.110 --> 00:43:49.220 align:middle line:84%
then I would return a list
which has at look photograph

00:43:49.220 --> 00:43:53.070 align:middle line:84%
and this as my four
elements in that order.

00:43:53.070 --> 00:43:55.700 align:middle line:90%


00:43:55.700 --> 00:44:03.531 align:middle line:84%
So here start writing
it down on line 134.

00:44:03.531 --> 00:44:06.740 align:middle line:90%
OK, what is the solution?

00:44:06.740 --> 00:44:07.740 align:middle line:90%
What do you have so far?

00:44:07.740 --> 00:44:16.870 align:middle line:90%


00:44:16.870 --> 00:44:17.880 align:middle line:90%
Yes.

00:44:17.880 --> 00:44:21.090 align:middle line:84%
STUDENT: L equals sen.split
with the [INAUDIBLE]..

00:44:21.090 --> 00:44:25.780 align:middle line:84%
ANA BELL: L equals sen.split
and we split on a space.

00:44:25.780 --> 00:44:26.450 align:middle line:90%
Got it.

00:44:26.450 --> 00:44:27.205 align:middle line:90%
OK.

00:44:27.205 --> 00:44:30.200 align:middle line:84%
STUDENT: And then L.sort
parentheses with nothing around.

00:44:30.200 --> 00:44:32.240 align:middle line:90%
ANA BELL: Got it.

00:44:32.240 --> 00:44:34.310 align:middle line:90%
Return L. Perfect.

00:44:34.310 --> 00:44:39.040 align:middle line:84%
OK, let's see if that worked
with our two examples.

00:44:39.040 --> 00:44:40.780 align:middle line:90%
Yep.

00:44:40.780 --> 00:44:41.840 align:middle line:90%
There's my first one.

00:44:41.840 --> 00:44:42.940 align:middle line:90%
There's my second one.

00:44:42.940 --> 00:44:44.810 align:middle line:90%
Anybody do it a different way?

00:44:44.810 --> 00:44:46.440 align:middle line:90%
Did anyone use sorted?

00:44:46.440 --> 00:44:47.467 align:middle line:90%
Yeah.

00:44:47.467 --> 00:44:51.760 align:middle line:84%
STUDENT: I just said return
sorted parentheses L.

00:44:51.760 --> 00:44:59.140 align:middle line:84%
ANA BELL: Return sorted
parentheses L. Yeah.

00:44:59.140 --> 00:45:01.300 align:middle line:90%
Is that how you--

00:45:01.300 --> 00:45:02.660 align:middle line:90%
STUDENT: [INAUDIBLE]

00:45:02.660 --> 00:45:04.180 align:middle line:90%


00:45:04.180 --> 00:45:04.810 align:middle line:90%
ANA BELL: Yep.

00:45:04.810 --> 00:45:05.960 align:middle line:90%
We could do it all in one.

00:45:05.960 --> 00:45:06.460 align:middle line:90%
Perfect.

00:45:06.460 --> 00:45:09.210 align:middle line:84%
Yeah, this could be a
one liner, for sure.

00:45:09.210 --> 00:45:14.760 align:middle line:84%
Yeah, so this works
because this thing here

00:45:14.760 --> 00:45:17.265 align:middle line:90%
creates for me a new object.

00:45:17.265 --> 00:45:19.140 align:middle line:84%
I could have saved it
in a different variable

00:45:19.140 --> 00:45:23.540 align:middle line:84%
and then returned that variable,
but this does it all in one.

00:45:23.540 --> 00:45:28.070 align:middle line:84%
So just for completion
sake, if we comment out

00:45:28.070 --> 00:45:30.625 align:middle line:84%
the other solution,
this way still works.

00:45:30.625 --> 00:45:35.360 align:middle line:90%


00:45:35.360 --> 00:45:36.625 align:middle line:90%
Questions so far?

00:45:36.625 --> 00:45:40.300 align:middle line:90%


00:45:40.300 --> 00:45:40.800 align:middle line:90%
OK.

00:45:40.800 --> 00:45:43.380 align:middle line:90%


00:45:43.380 --> 00:45:43.900 align:middle line:90%
All right.

00:45:43.900 --> 00:45:47.340 align:middle line:84%
So what we've seen
so far is a bunch

00:45:47.340 --> 00:45:49.710 align:middle line:84%
of these functions,
built in functions,

00:45:49.710 --> 00:45:52.090 align:middle line:90%
that have these side effects.

00:45:52.090 --> 00:45:55.470 align:middle line:90%
They mutate the input list.

00:45:55.470 --> 00:45:58.320 align:middle line:84%
So we can actually
write our own functions

00:45:58.320 --> 00:46:03.060 align:middle line:84%
that have a side effect, where
if we pass in a parameter that's

00:46:03.060 --> 00:46:06.150 align:middle line:84%
a list, we can have
our functions mutate

00:46:06.150 --> 00:46:09.240 align:middle line:90%
that list however we'd like.

00:46:09.240 --> 00:46:11.740 align:middle line:84%
So let's go through
this example.

00:46:11.740 --> 00:46:15.690 align:middle line:84%
Let's say we were given the
task of writing a function that

00:46:15.690 --> 00:46:19.350 align:middle line:84%
takes an input
list L and mutates

00:46:19.350 --> 00:46:22.710 align:middle line:84%
the list L such that
each element in L

00:46:22.710 --> 00:46:26.200 align:middle line:84%
is changed to be
the element square.

00:46:26.200 --> 00:46:32.670 align:middle line:84%
So 2, 3, and 4 as an input
list becomes 4, 9, 16.

00:46:32.670 --> 00:46:34.600 align:middle line:90%
And I'm mutating that list.

00:46:34.600 --> 00:46:38.110 align:middle line:84%
I'm not creating a new list
and returning the new list.

00:46:38.110 --> 00:46:42.500 align:middle line:84%
I want to actually
mutate the input list L.

00:46:42.500 --> 00:46:45.020 align:middle line:84%
So if we were faced
with this task,

00:46:45.020 --> 00:46:47.570 align:middle line:84%
the way that we would
go about it, maybe

00:46:47.570 --> 00:46:50.060 align:middle line:84%
based on what we've learned
so far, is to say, well,

00:46:50.060 --> 00:46:52.370 align:middle line:84%
I'm going to iterate
through each element in L

00:46:52.370 --> 00:46:54.960 align:middle line:84%
because that's a very
Pythonic way to do this.

00:46:54.960 --> 00:46:57.890 align:middle line:84%
So I'm grabbing the
element in the list L.

00:46:57.890 --> 00:47:00.990 align:middle line:90%
But then I would be stuck.

00:47:00.990 --> 00:47:04.560 align:middle line:84%
Because the syntax for
changing an element

00:47:04.560 --> 00:47:07.980 align:middle line:84%
at a particular
location is L at I

00:47:07.980 --> 00:47:13.690 align:middle line:84%
equals whatever the
changed thing is.

00:47:13.690 --> 00:47:16.870 align:middle line:84%
But my loop variable is
iterating through the element

00:47:16.870 --> 00:47:18.330 align:middle line:90%
directly.

00:47:18.330 --> 00:47:21.010 align:middle line:84%
So what's my index in
this particular case?

00:47:21.010 --> 00:47:22.540 align:middle line:90%
I don't have it in hand.

00:47:22.540 --> 00:47:25.750 align:middle line:84%
I have the element, but
I don't have the index.

00:47:25.750 --> 00:47:28.570 align:middle line:90%
So what are some solutions?

00:47:28.570 --> 00:47:32.650 align:middle line:84%
Well, a first solution could
be right before the loop

00:47:32.650 --> 00:47:36.290 align:middle line:84%
to create a new variable that
keeps track of the index.

00:47:36.290 --> 00:47:39.290 align:middle line:84%
So you make I equals 0
right before the for loop.

00:47:39.290 --> 00:47:42.500 align:middle line:84%
And inside the for loop,
you increment I each time.

00:47:42.500 --> 00:47:45.540 align:middle line:84%
Now you're keeping track
of the index yourself.

00:47:45.540 --> 00:47:48.310 align:middle line:84%
Option two is to change
what we iterate over.

00:47:48.310 --> 00:47:50.850 align:middle line:84%
So instead of iterating through
each element in L directly,

00:47:50.850 --> 00:47:52.920 align:middle line:90%
let's iterate over the index.

00:47:52.920 --> 00:47:57.750 align:middle line:84%
So iterate over range
length L. In that case,

00:47:57.750 --> 00:48:02.820 align:middle line:84%
the range length L basically
becomes range 5 or 20

00:48:02.820 --> 00:48:05.320 align:middle line:84%
or whatever the
length of my list is.

00:48:05.320 --> 00:48:11.200 align:middle line:84%
And a last option is to try to
use this thing called enumerate,

00:48:11.200 --> 00:48:17.230 align:middle line:84%
which is a Python keyword,
I guess, Python function.

00:48:17.230 --> 00:48:20.740 align:middle line:84%
And the syntax for that
would be for tuple I comma e

00:48:20.740 --> 00:48:25.030 align:middle line:84%
in enumerate L. So I'm
basically wrapping L

00:48:25.030 --> 00:48:26.980 align:middle line:90%
inside this enumerate function.

00:48:26.980 --> 00:48:29.950 align:middle line:84%
And Python each time
through the loop

00:48:29.950 --> 00:48:32.680 align:middle line:84%
makes this little
tuple I comma e

00:48:32.680 --> 00:48:37.985 align:middle line:84%
be the index and the
element at each location

00:48:37.985 --> 00:48:39.110 align:middle line:90%
each time through the loop.

00:48:39.110 --> 00:48:41.980 align:middle line:84%
And so it gives you a two for
one kind of deal here using

00:48:41.980 --> 00:48:43.330 align:middle line:90%
this enumerate function.

00:48:43.330 --> 00:48:45.740 align:middle line:84%
I'm not going to go over
option one or option three.

00:48:45.740 --> 00:48:48.125 align:middle line:84%
I do encourage you to try
to look these up or try

00:48:48.125 --> 00:48:49.250 align:middle line:90%
to implement them yourself.

00:48:49.250 --> 00:48:54.620 align:middle line:84%
But I will go over option
two in these slides.

00:48:54.620 --> 00:48:58.910 align:middle line:84%
So if I were to iterate
over the index directly,

00:48:58.910 --> 00:49:03.890 align:middle line:84%
the way I do it is I'd have to
change the loop variable for I

00:49:03.890 --> 00:49:04.710 align:middle line:90%
in.

00:49:04.710 --> 00:49:11.160 align:middle line:84%
And then the thing I want to
loop over is all of the indices.

00:49:11.160 --> 00:49:14.060 align:middle line:84%
So I want to get the
numbers 0, 1, 2, 3,

00:49:14.060 --> 00:49:19.720 align:middle line:84%
4, all the way up to the but
not including the length of L.

00:49:19.720 --> 00:49:22.060 align:middle line:84%
So once I have
this index in hand,

00:49:22.060 --> 00:49:25.720 align:middle line:84%
I can do something like this
very easily, because this I here

00:49:25.720 --> 00:49:28.850 align:middle line:90%
is going to be my index.

00:49:28.850 --> 00:49:30.730 align:middle line:84%
And the thing on
the right hand side

00:49:30.730 --> 00:49:33.280 align:middle line:84%
is just going to be a matter
of grabbing the element

00:49:33.280 --> 00:49:36.620 align:middle line:90%
at that index and squaring it.

00:49:36.620 --> 00:49:41.480 align:middle line:84%
So here L square brackets I on
the right hand side grabs for me

00:49:41.480 --> 00:49:43.680 align:middle line:90%
the element at index I.

00:49:43.680 --> 00:49:45.740 align:middle line:84%
So what's the value
of that element

00:49:45.740 --> 00:49:47.550 align:middle line:90%
at that particular location?

00:49:47.550 --> 00:49:49.340 align:middle line:90%
23 whatever.

00:49:49.340 --> 00:49:50.550 align:middle line:90%
Square it.

00:49:50.550 --> 00:49:52.410 align:middle line:90%
So **2 squares it.

00:49:52.410 --> 00:49:55.250 align:middle line:84%
And then the thing
on the left hand side

00:49:55.250 --> 00:49:58.910 align:middle line:84%
is the syntax for
changing the element

00:49:58.910 --> 00:50:00.150 align:middle line:90%
at a particular location.

00:50:00.150 --> 00:50:04.160 align:middle line:84%
We saw this way
back on slide two.

00:50:04.160 --> 00:50:06.080 align:middle line:84%
So with this line
of code, Python

00:50:06.080 --> 00:50:08.750 align:middle line:84%
goes through each element
in the list and squares it

00:50:08.750 --> 00:50:11.400 align:middle line:84%
and saves it back
into that same list.

00:50:11.400 --> 00:50:13.200 align:middle line:90%
No new list is created.

00:50:13.200 --> 00:50:16.430 align:middle line:90%
It's mutating the original list.

00:50:16.430 --> 00:50:19.170 align:middle line:90%
No return.

00:50:19.170 --> 00:50:20.440 align:middle line:90%
Nothing to return.

00:50:20.440 --> 00:50:22.710 align:middle line:84%
This function will return
none because it does

00:50:22.710 --> 00:50:24.810 align:middle line:90%
its job of doing the mutation.

00:50:24.810 --> 00:50:29.610 align:middle line:84%
So if we go through an example,
suppose that L is 2, 3, 4.

00:50:29.610 --> 00:50:31.710 align:middle line:90%
What is this loop going to do?

00:50:31.710 --> 00:50:35.340 align:middle line:84%
So I the first time
through the loop will be 0.

00:50:35.340 --> 00:50:40.180 align:middle line:84%
And then that first time through
the loop, it will mutate I.

00:50:40.180 --> 00:50:45.220 align:middle line:84%
So it says L square bracket 0
equals whatever the element at 0

00:50:45.220 --> 00:50:47.870 align:middle line:90%
is, the 2 squared.

00:50:47.870 --> 00:50:51.520 align:middle line:84%
So L square bracket 0
will be changed to 4.

00:50:51.520 --> 00:50:55.450 align:middle line:84%
So we've mutated the element
at index 0 to be a 4,

00:50:55.450 --> 00:50:56.900 align:middle line:90%
and everything else is the same.

00:50:56.900 --> 00:51:00.970 align:middle line:84%
Next time through the
loop, I'm mutating the list

00:51:00.970 --> 00:51:02.480 align:middle line:90%
that I had just mutated.

00:51:02.480 --> 00:51:05.950 align:middle line:84%
So the first element is
still the mutated value 4.

00:51:05.950 --> 00:51:09.460 align:middle line:84%
But now I'm going to change
my element at index 1

00:51:09.460 --> 00:51:11.630 align:middle line:90%
to be 3 squared 9.

00:51:11.630 --> 00:51:16.240 align:middle line:84%
The last time through the loop,
all the elements up to index 2

00:51:16.240 --> 00:51:17.990 align:middle line:84%
are going to be the
mutated elements.

00:51:17.990 --> 00:51:18.885 align:middle line:90%
So 4 and 9.

00:51:18.885 --> 00:51:20.510 align:middle line:84%
And then the last
time through the loop

00:51:20.510 --> 00:51:24.690 align:middle line:84%
by mutating the 4 to be 16,
the square version of that.

00:51:24.690 --> 00:51:27.540 align:middle line:90%


00:51:27.540 --> 00:51:32.700 align:middle line:84%
So to check that we did
the mutation correctly,

00:51:32.700 --> 00:51:36.190 align:middle line:84%
what we would do is we
would create an input list.

00:51:36.190 --> 00:51:37.470 align:middle line:90%
I called it L in.

00:51:37.470 --> 00:51:41.760 align:middle line:84%
And I've set it to
2, 3, 4, my example.

00:51:41.760 --> 00:51:45.240 align:middle line:84%
If I print before the function,
call the value of L in,

00:51:45.240 --> 00:51:47.640 align:middle line:84%
it's 2 comma 3 comma
4, as expected.

00:51:47.640 --> 00:51:49.990 align:middle line:84%
It shouldn't be anything
different than that.

00:51:49.990 --> 00:51:53.710 align:middle line:84%
Then I make a function call to
the function that we just wrote.

00:51:53.710 --> 00:51:57.060 align:middle line:84%
Note I'm not returning
anything here.

00:51:57.060 --> 00:52:02.930 align:middle line:84%
So I'm not saving the
function call to any variable.

00:52:02.930 --> 00:52:06.140 align:middle line:84%
If I print L in after
the function call,

00:52:06.140 --> 00:52:08.310 align:middle line:90%
it will print the mutated list.

00:52:08.310 --> 00:52:13.640 align:middle line:84%
So this L in here and here
and here is the same object.

00:52:13.640 --> 00:52:15.120 align:middle line:90%
Nothing was returned.

00:52:15.120 --> 00:52:19.020 align:middle line:84%
This function here has nothing
to assign its return to.

00:52:19.020 --> 00:52:22.228 align:middle line:84%
If we assigned it to something,
that variable would be none.

00:52:22.228 --> 00:52:24.895 align:middle line:84%
Just like the append, just like
the sort, just like the reverse.

00:52:24.895 --> 00:52:28.850 align:middle line:90%


00:52:28.850 --> 00:52:29.460 align:middle line:90%
All right.

00:52:29.460 --> 00:52:30.560 align:middle line:90%
So when you're writing--

00:52:30.560 --> 00:52:32.068 align:middle line:90%
oh yeah, question.

00:52:32.068 --> 00:52:33.485 align:middle line:84%
STUDENT: So we
created a function,

00:52:33.485 --> 00:52:39.397 align:middle line:84%
but we don't have a return
and it doesn't say none.

00:52:39.397 --> 00:52:40.730 align:middle line:90%
ANA BELL: We created a function.

00:52:40.730 --> 00:52:42.100 align:middle line:90%
It doesn't have a return.

00:52:42.100 --> 00:52:44.900 align:middle line:84%
It doesn't say none because
we didn't save the function

00:52:44.900 --> 00:52:46.610 align:middle line:90%
call to any variable.

00:52:46.610 --> 00:52:53.000 align:middle line:84%
If we said A equals this
function call, if we print A,

00:52:53.000 --> 00:52:54.055 align:middle line:90%
it would show none.

00:52:54.055 --> 00:52:54.555 align:middle line:90%
Yeah.

00:52:54.555 --> 00:52:57.270 align:middle line:90%


00:52:57.270 --> 00:52:59.010 align:middle line:84%
OK, so when we're
writing functions

00:52:59.010 --> 00:53:02.690 align:middle line:84%
that mutate input lists,
the two likely things

00:53:02.690 --> 00:53:04.440 align:middle line:84%
you're going to have
to do, and it depends

00:53:04.440 --> 00:53:06.780 align:middle line:84%
on what your function is
actually doing, but most likely

00:53:06.780 --> 00:53:09.280 align:middle line:84%
you're going to have to iterate
over the length of the list.

00:53:09.280 --> 00:53:13.290 align:middle line:84%
So for I in range length L
to grab the index as well

00:53:13.290 --> 00:53:14.370 align:middle line:90%
as the element.

00:53:14.370 --> 00:53:16.990 align:middle line:84%
To be able to grab the index
as well as the element.

00:53:16.990 --> 00:53:20.160 align:middle line:84%
And these functions, I mean,
they could do other stuff.

00:53:20.160 --> 00:53:23.100 align:middle line:84%
But if you're using them for
mutation and things like that,

00:53:23.100 --> 00:53:24.640 align:middle line:90%
they're going to return none.

00:53:24.640 --> 00:53:26.970 align:middle line:84%
So when you make
function calls to them,

00:53:26.970 --> 00:53:29.730 align:middle line:84%
those function calls will
likely just be on a line

00:53:29.730 --> 00:53:32.315 align:middle line:84%
without saving the
return to any variable.

00:53:32.315 --> 00:53:35.020 align:middle line:90%


00:53:35.020 --> 00:53:38.240 align:middle line:84%
So we've talked about
mutable objects.

00:53:38.240 --> 00:53:41.260 align:middle line:90%
They're very, very useful.

00:53:41.260 --> 00:53:44.650 align:middle line:84%
Places where they're useful or
the reason that they're useful

00:53:44.650 --> 00:53:49.030 align:middle line:84%
is because they allow you to
have basically large databases

00:53:49.030 --> 00:53:55.450 align:middle line:84%
of objects like employees in a
company list of all the students

00:53:55.450 --> 00:53:57.340 align:middle line:90%
at MIT, things like that.

00:53:57.340 --> 00:54:02.320 align:middle line:84%
And if you want to make a change
to something about that list,

00:54:02.320 --> 00:54:04.600 align:middle line:84%
like a student changes
their name or their address

00:54:04.600 --> 00:54:07.150 align:middle line:84%
or something like
that, with tuples,

00:54:07.150 --> 00:54:10.310 align:middle line:84%
you'd have to make a new
copy of that entire list.

00:54:10.310 --> 00:54:12.730 align:middle line:84%
So it could be very
space inefficient,

00:54:12.730 --> 00:54:14.860 align:middle line:84%
because every time
a student changes

00:54:14.860 --> 00:54:17.625 align:middle line:84%
their address or their name
or something about themselves

00:54:17.625 --> 00:54:19.000 align:middle line:84%
or their grades
or something like

00:54:19.000 --> 00:54:22.060 align:middle line:84%
that, you're making a new
copy of this potentially

00:54:22.060 --> 00:54:25.480 align:middle line:90%
thousands long data structure.

00:54:25.480 --> 00:54:27.730 align:middle line:90%
Lists don't have that issue.

00:54:27.730 --> 00:54:30.310 align:middle line:84%
With lists, you're just
mutating the object in place

00:54:30.310 --> 00:54:31.010 align:middle line:90%
and you're done.

00:54:31.010 --> 00:54:33.700 align:middle line:84%
No extra copies are being made,
so it's a very efficient data

00:54:33.700 --> 00:54:34.670 align:middle line:90%
structure.

00:54:34.670 --> 00:54:37.383 align:middle line:84%
But with lists come some
unexpected challenges.

00:54:37.383 --> 00:54:39.800 align:middle line:84%
And we're going to go through
three tricky examples today.

00:54:39.800 --> 00:54:42.770 align:middle line:84%
In next lecture, we're going to
see tricky example number four.

00:54:42.770 --> 00:54:46.090 align:middle line:84%
And these three tricky
examples involve looping over

00:54:46.090 --> 00:54:47.650 align:middle line:90%
the list in one way or another.

00:54:47.650 --> 00:54:50.170 align:middle line:84%
Over the range of the length
of the list or through the list

00:54:50.170 --> 00:54:51.990 align:middle line:90%
directly.

00:54:51.990 --> 00:54:53.630 align:middle line:84%
So let's look at
the first example.

00:54:53.630 --> 00:54:56.430 align:middle line:90%


00:54:56.430 --> 00:54:59.280 align:middle line:84%
In this code down
here, we're going

00:54:59.280 --> 00:55:02.440 align:middle line:84%
to loop over the range
of the length of the L.

00:55:02.440 --> 00:55:08.130 align:middle line:84%
And then what we're going to do
is append the loop variable I

00:55:08.130 --> 00:55:11.930 align:middle line:90%
to the end of my list.

00:55:11.930 --> 00:55:15.750 align:middle line:84%
Now, what does
range length L do?

00:55:15.750 --> 00:55:20.270 align:middle line:84%
So remember the thing
that our for loop iterates

00:55:20.270 --> 00:55:22.800 align:middle line:90%
over is a sequence of values.

00:55:22.800 --> 00:55:27.780 align:middle line:84%
Now, range some number creates
for us a tuple like object.

00:55:27.780 --> 00:55:29.460 align:middle line:84%
Not a tuple
specifically, but you

00:55:29.460 --> 00:55:31.630 align:middle line:90%
can think of it like a tuple.

00:55:31.630 --> 00:55:35.040 align:middle line:84%
So range 4, the length
of this particular list,

00:55:35.040 --> 00:55:38.350 align:middle line:84%
would create for us in memory
something like a tuple.

00:55:38.350 --> 00:55:40.750 align:middle line:90%
The sequence 0, 1, 2, 3.

00:55:40.750 --> 00:55:42.780 align:middle line:84%
And this is the
sequence that the loop

00:55:42.780 --> 00:55:44.545 align:middle line:90%
variable I will go over.

00:55:44.545 --> 00:55:46.920 align:middle line:84%
First it will be 0, then it
will be 1, then it will be 2,

00:55:46.920 --> 00:55:49.470 align:middle line:90%
then it'll be 3.

00:55:49.470 --> 00:55:52.050 align:middle line:84%
So when we iterate
through the sequence,

00:55:52.050 --> 00:55:56.260 align:middle line:84%
Python says, OK, the first time
I encountered this for loop,

00:55:56.260 --> 00:55:59.340 align:middle line:84%
I'm going to save this
sequence I need to iterate over

00:55:59.340 --> 00:56:01.118 align:middle line:90%
as an object in memory.

00:56:01.118 --> 00:56:02.910 align:middle line:84%
And then I'm going to
have my loop variable

00:56:02.910 --> 00:56:05.410 align:middle line:84%
iterate over each one
of these elements.

00:56:05.410 --> 00:56:08.740 align:middle line:84%
The thing I'm doing is appending
I to the end of a list.

00:56:08.740 --> 00:56:10.530 align:middle line:84%
So the first time
through the list I'm

00:56:10.530 --> 00:56:12.310 align:middle line:90%
going to append a 0 to the end.

00:56:12.310 --> 00:56:15.900 align:middle line:84%
So the 0 being this
loop variable here.

00:56:15.900 --> 00:56:18.850 align:middle line:84%
Next time through the list,
I'm appending the 1 to the list

00:56:18.850 --> 00:56:21.590 align:middle line:90%
I just mutated.

00:56:21.590 --> 00:56:25.670 align:middle line:84%
Next time, I'm appending the
2 to the list I just mutated.

00:56:25.670 --> 00:56:27.290 align:middle line:84%
And the last time
through the list,

00:56:27.290 --> 00:56:31.230 align:middle line:84%
I'm appending the 3 to
the list I just mutated.

00:56:31.230 --> 00:56:32.690 align:middle line:90%
And we finish.

00:56:32.690 --> 00:56:34.750 align:middle line:90%
We've gone through four times.

00:56:34.750 --> 00:56:37.360 align:middle line:84%
We've appended four items
to the end of the list.

00:56:37.360 --> 00:56:45.060 align:middle line:84%
0, 1, 2, and 3, the
elements of my sequence

00:56:45.060 --> 00:56:47.300 align:middle line:90%
that I'm iterating over.

00:56:47.300 --> 00:56:51.160 align:middle line:84%
Let's look at the
memory diagram.

00:56:51.160 --> 00:56:54.650 align:middle line:90%
So originally L is 1, 2, 3, 4.

00:56:54.650 --> 00:56:58.060 align:middle line:84%
What exactly happens when we
first encounter range length L?

00:56:58.060 --> 00:57:02.080 align:middle line:84%
That gets put as a variable,
this tuple like thing.

00:57:02.080 --> 00:57:05.840 align:middle line:84%
I made it be a tuple, but it's
not exactly a tuple in memory.

00:57:05.840 --> 00:57:08.210 align:middle line:84%
And this I will iterate
through each one

00:57:08.210 --> 00:57:09.830 align:middle line:90%
of these values in my sequence.

00:57:09.830 --> 00:57:16.760 align:middle line:84%
This is the sequence of values
that I'm going to iterate over.

00:57:16.760 --> 00:57:19.970 align:middle line:84%
So the first time
through the loop, Python

00:57:19.970 --> 00:57:22.370 align:middle line:90%
has I pointing to 0 here.

00:57:22.370 --> 00:57:24.840 align:middle line:84%
And so what's it
doing inside the loop?

00:57:24.840 --> 00:57:30.390 align:middle line:84%
It's going to append the 0 to
the end of L. Next time through,

00:57:30.390 --> 00:57:32.580 align:middle line:84%
then it's going
to print L. Sorry.

00:57:32.580 --> 00:57:35.010 align:middle line:84%
And then next time
through the loop,

00:57:35.010 --> 00:57:37.090 align:middle line:84%
the loop variable
increments by 1.

00:57:37.090 --> 00:57:38.970 align:middle line:84%
So we've already
looked at the 0.

00:57:38.970 --> 00:57:40.820 align:middle line:90%
Now we're going to do the 1.

00:57:40.820 --> 00:57:42.655 align:middle line:90%
So the loop variable I is now 1.

00:57:42.655 --> 00:57:44.030 align:middle line:84%
So we're going to
append the loop

00:57:44.030 --> 00:57:48.930 align:middle line:84%
variable 1 to the end of
L. Print L. Loop variable

00:57:48.930 --> 00:57:49.860 align:middle line:90%
becomes 2.

00:57:49.860 --> 00:57:53.730 align:middle line:84%
Append the loop variable to the
end of L. So now it has a 2.

00:57:53.730 --> 00:57:56.670 align:middle line:84%
Print L. And then
the last time we

00:57:56.670 --> 00:57:59.730 align:middle line:84%
append the loop variable
3 to the end of the list L

00:57:59.730 --> 00:58:01.800 align:middle line:90%
and print L.

00:58:01.800 --> 00:58:03.040 align:middle line:90%
Pretty straightforward.

00:58:03.040 --> 00:58:05.370 align:middle line:84%
The code terminates
because we've

00:58:05.370 --> 00:58:09.360 align:middle line:84%
created this original
tuple-like object here,

00:58:09.360 --> 00:58:12.600 align:middle line:84%
which tells Python what values
you need to iterate over.

00:58:12.600 --> 00:58:14.645 align:middle line:84%
This is your sequence
of values to go through.

00:58:14.645 --> 00:58:17.720 align:middle line:90%


00:58:17.720 --> 00:58:20.810 align:middle line:90%
So that's basically what I said.

00:58:20.810 --> 00:58:23.430 align:middle line:84%
So let's look at a
slightly different example.

00:58:23.430 --> 00:58:26.960 align:middle line:84%
So in this case, instead of
iterating over the range length

00:58:26.960 --> 00:58:30.840 align:middle line:84%
L, let's iterate over the
elements in L directly.

00:58:30.840 --> 00:58:36.050 align:middle line:84%
So for e in L. Now, to
keep things in parallel

00:58:36.050 --> 00:58:38.000 align:middle line:84%
to what we had
done before, let's

00:58:38.000 --> 00:58:41.148 align:middle line:84%
create a loop variable I
equals 0 before the for loop

00:58:41.148 --> 00:58:43.440 align:middle line:84%
and let's increment it by 1
each time through the loop.

00:58:43.440 --> 00:58:46.280 align:middle line:84%
So we're going to still append
0, then 1, then 2, then 3

00:58:46.280 --> 00:58:48.250 align:middle line:90%
to the end of our list.

00:58:48.250 --> 00:58:52.393 align:middle line:84%
So in this particular
case, we start out

00:58:52.393 --> 00:58:53.810 align:middle line:84%
with the memory
diagram like this.

00:58:53.810 --> 00:58:57.500 align:middle line:84%
So we have L pointing
to 1, 2, 3, 4.

00:58:57.500 --> 00:59:01.010 align:middle line:84%
Loop variable I is going
to be 0 originally.

00:59:01.010 --> 00:59:05.270 align:middle line:84%
And e will first point to the
first element in the list.

00:59:05.270 --> 00:59:09.000 align:middle line:84%
That's what for loop over the
elements in the list does.

00:59:09.000 --> 00:59:15.120 align:middle line:84%
So going into the list, we say
L.append I. So at the end of L,

00:59:15.120 --> 00:59:19.520 align:middle line:84%
I'm going to mutate
it to contain a 0.

00:59:19.520 --> 00:59:20.720 align:middle line:90%
Good?

00:59:20.720 --> 00:59:22.990 align:middle line:90%
I increment I by 1.

00:59:22.990 --> 00:59:23.890 align:middle line:90%
Good.

00:59:23.890 --> 00:59:26.010 align:middle line:90%
I print L OK, good.

00:59:26.010 --> 00:59:28.610 align:middle line:84%
And then the next time
through the loop, Python says,

00:59:28.610 --> 00:59:31.580 align:middle line:84%
all right, what's the next
element in my sequence?

00:59:31.580 --> 00:59:33.830 align:middle line:90%
Well, I looked at the 1 first.

00:59:33.830 --> 00:59:36.590 align:middle line:90%
Now let me look at the 2.

00:59:36.590 --> 00:59:37.290 align:middle line:90%
All right.

00:59:37.290 --> 00:59:40.050 align:middle line:84%
Now I'm looking at the 2 as
my next element in sequence.

00:59:40.050 --> 00:59:42.450 align:middle line:84%
I'm going to append I
to the end of the list.

00:59:42.450 --> 00:59:47.800 align:middle line:84%
So I'm going to append 1 to
the end of L. Increment I

00:59:47.800 --> 00:59:49.120 align:middle line:90%
by 1 to be 2.

00:59:49.120 --> 00:59:54.410 align:middle line:84%
Print L. OK, next
value in my sequence.

00:59:54.410 --> 00:59:59.170 align:middle line:84%
e increments to the next
element in the sequence, the 3.

00:59:59.170 --> 01:00:01.220 align:middle line:84%
We append I to the
end of the list.

01:00:01.220 --> 01:00:04.560 align:middle line:84%
So we append 2 to the end
of L. Increment I by 1.

01:00:04.560 --> 01:00:05.380 align:middle line:90%
Print L.

01:00:05.380 --> 01:00:06.360 align:middle line:90%
What do you notice?

01:00:06.360 --> 01:00:10.160 align:middle line:90%


01:00:10.160 --> 01:00:12.410 align:middle line:90%
Is this code going to terminate?

01:00:12.410 --> 01:00:16.520 align:middle line:84%
No, because our loop
variable will always

01:00:16.520 --> 01:00:19.940 align:middle line:84%
be four elements away from
the list, the end of the list.

01:00:19.940 --> 01:00:23.090 align:middle line:84%
As I'm adding an item
to the end of my list,

01:00:23.090 --> 01:00:24.938 align:middle line:84%
the loop variable
iterates to the next item.

01:00:24.938 --> 01:00:27.230 align:middle line:84%
But then I'm adding another
item to the end of my list,

01:00:27.230 --> 01:00:28.980 align:middle line:90%
and my loop variable iterates.

01:00:28.980 --> 01:00:32.190 align:middle line:84%
And so we're always going to be
4 behind the end of the list.

01:00:32.190 --> 01:00:34.525 align:middle line:84%
So this code will
actually never stop.

01:00:34.525 --> 01:00:38.900 align:middle line:90%


01:00:38.900 --> 01:00:41.260 align:middle line:90%
All right.

01:00:41.260 --> 01:00:44.110 align:middle line:84%
So the difference here is
what I'm iterating over.

01:00:44.110 --> 01:00:47.290 align:middle line:84%
In the previous example, as soon
as Python saw range, length,

01:00:47.290 --> 01:00:50.530 align:middle line:84%
whatever, it made this
predefined sequence of values

01:00:50.530 --> 01:00:52.070 align:middle line:90%
it needed to iterate over.

01:00:52.070 --> 01:00:55.270 align:middle line:84%
But here it doesn't do that,
because it's iterating over

01:00:55.270 --> 01:00:58.610 align:middle line:84%
my object L. There's no
predefined sequence to create.

01:00:58.610 --> 01:01:01.720 align:middle line:84%
It's supposed to
iterate over L directly.

01:01:01.720 --> 01:01:04.650 align:middle line:84%
So that's the difference
between these two.

01:01:04.650 --> 01:01:05.150 align:middle line:90%
All right.

01:01:05.150 --> 01:01:06.820 align:middle line:90%
So now I'm going to show you--

01:01:06.820 --> 01:01:10.010 align:middle line:84%
before I do the last trick
example involving concatenation,

01:01:10.010 --> 01:01:11.590 align:middle line:84%
I wanted to mention
one thing, which

01:01:11.590 --> 01:01:13.840 align:middle line:84%
is there was a
question earlier, how

01:01:13.840 --> 01:01:17.540 align:middle line:84%
do we actually add more than
one item to the end of our list?

01:01:17.540 --> 01:01:20.690 align:middle line:84%
And we do that using
this extend operation.

01:01:20.690 --> 01:01:24.580 align:middle line:84%
And this extend operation
is kind of like append,

01:01:24.580 --> 01:01:29.080 align:middle line:84%
but we are going to add all
of the elements of some list

01:01:29.080 --> 01:01:33.010 align:middle line:84%
as the parameter to
the end of our list L.

01:01:33.010 --> 01:01:35.650 align:middle line:84%
So in effect, we're
mutating L to be

01:01:35.650 --> 01:01:40.540 align:middle line:84%
extended by all the elements
in some underscore list.

01:01:40.540 --> 01:01:42.370 align:middle line:90%
So here's an example.

01:01:42.370 --> 01:01:44.650 align:middle line:84%
First, let's do concatenation
just to remind ourselves

01:01:44.650 --> 01:01:45.350 align:middle line:90%
what it does.

01:01:45.350 --> 01:01:47.350 align:middle line:90%
So L1 is 2, 1, 3 in memory.

01:01:47.350 --> 01:01:49.300 align:middle line:90%
L2 is 4, 5, 6 in memory.

01:01:49.300 --> 01:01:52.460 align:middle line:84%
L3 is going to be L1
concatenated with L2.

01:01:52.460 --> 01:01:53.660 align:middle line:90%
Pretty straightforward.

01:01:53.660 --> 01:01:54.860 align:middle line:90%
It's concatenation.

01:01:54.860 --> 01:01:57.550 align:middle line:84%
So Python creates
for me a new object,

01:01:57.550 --> 01:01:59.860 align:middle line:84%
which is all the
objects in L1 and L2

01:01:59.860 --> 01:02:05.000 align:middle line:84%
put together as this completely
new object bound to the name L3.

01:02:05.000 --> 01:02:07.550 align:middle line:90%
So L1 and L2 remain unchanged.

01:02:07.550 --> 01:02:09.400 align:middle line:90%
No problems there.

01:02:09.400 --> 01:02:13.790 align:middle line:84%
But the extend is
going to mutate.

01:02:13.790 --> 01:02:17.650 align:middle line:84%
Notice the dot notation
format of extend.

01:02:17.650 --> 01:02:20.950 align:middle line:84%
It's going to mutate L1
to be extended by all

01:02:20.950 --> 01:02:23.220 align:middle line:90%
the elements in this list.

01:02:23.220 --> 01:02:27.620 align:middle line:84%
So it's going to add a 0
and a 6 to the end of L1.

01:02:27.620 --> 01:02:29.090 align:middle line:90%
So here it is.

01:02:29.090 --> 01:02:34.160 align:middle line:84%
I've got L1 mutated to be 2,
1, 3, and then 0 and then 6.

01:02:34.160 --> 01:02:37.630 align:middle line:84%
So just to bring the point home,
the thing we're extending by

01:02:37.630 --> 01:02:43.090 align:middle line:84%
is all of the elements of
this list in the parameter.

01:02:43.090 --> 01:02:46.180 align:middle line:84%
So in this particular
case, L2.extend

01:02:46.180 --> 01:02:50.260 align:middle line:84%
will be extended by
how many elements?

01:02:50.260 --> 01:02:51.340 align:middle line:90%
2 or 4?

01:02:51.340 --> 01:02:55.660 align:middle line:90%


01:02:55.660 --> 01:02:57.800 align:middle line:90%
Yeah, I see 2.

01:02:57.800 --> 01:02:58.420 align:middle line:90%
Exactly.

01:02:58.420 --> 01:02:59.860 align:middle line:90%
It'll be extended by 2 elements.

01:02:59.860 --> 01:03:03.640 align:middle line:84%
At the top level, this list
has two elements in it, a list

01:03:03.640 --> 01:03:05.200 align:middle line:90%
and then another list.

01:03:05.200 --> 01:03:10.180 align:middle line:84%
So this command here will
extend L2 by these two elements

01:03:10.180 --> 01:03:14.840 align:middle line:84%
specifically, 1 comma 2 as a
list and 3 comma 4 as a list.

01:03:14.840 --> 01:03:16.880 align:middle line:84%
But these are
individual objects.

01:03:16.880 --> 01:03:18.740 align:middle line:84%
They're single objects
that are lists.

01:03:18.740 --> 01:03:21.400 align:middle line:84%
They happen to have a bunch of
elements as part of the list,

01:03:21.400 --> 01:03:24.220 align:middle line:90%
but they are two objects.

01:03:24.220 --> 01:03:25.172 align:middle line:90%
Yeah.

01:03:25.172 --> 01:03:26.820 align:middle line:90%
STUDENT: [INAUDIBLE]

01:03:26.820 --> 01:03:34.900 align:middle line:90%


01:03:34.900 --> 01:03:37.040 align:middle line:84%
ANA BELL: When we
extended by 0 comma 6,

01:03:37.040 --> 01:03:38.710 align:middle line:84%
there's no brackets
because we're

01:03:38.710 --> 01:03:41.750 align:middle line:84%
extending it by the elements
of this top level list.

01:03:41.750 --> 01:03:44.000 align:middle line:90%
So it's two integers.

01:03:44.000 --> 01:03:47.580 align:middle line:84%
And here we're extending it by
the elements of this top level

01:03:47.580 --> 01:03:48.080 align:middle line:90%
list.

01:03:48.080 --> 01:03:50.950 align:middle line:84%
So in a sense, the
outermost parentheses,

01:03:50.950 --> 01:03:55.258 align:middle line:90%
which they are lists.

01:03:55.258 --> 01:03:55.758 align:middle line:90%
Yeah.

01:03:55.758 --> 01:04:02.332 align:middle line:90%


01:04:02.332 --> 01:04:03.687 align:middle line:90%
So that introduces extent.

01:04:03.687 --> 01:04:05.270 align:middle line:84%
We're not actually
going to use extent

01:04:05.270 --> 01:04:07.850 align:middle line:84%
for this particular example,
but I did want to mention it.

01:04:07.850 --> 01:04:11.660 align:middle line:84%
In this example, we're going to
use the concatenation operator

01:04:11.660 --> 01:04:19.260 align:middle line:84%
to create for us this new
object and bind it to L again.

01:04:19.260 --> 01:04:22.290 align:middle line:84%
So let's see what
this is going to do.

01:04:22.290 --> 01:04:24.930 align:middle line:84%
First, I'm going to actually
tell you the answer,

01:04:24.930 --> 01:04:27.090 align:middle line:84%
and then we'll do the
memory diagram again

01:04:27.090 --> 01:04:28.360 align:middle line:90%
to bring the point home.

01:04:28.360 --> 01:04:33.330 align:middle line:84%
So this loop will, again,
loop through all the elements

01:04:33.330 --> 01:04:39.240 align:middle line:84%
in L. Originally it's
1, 2, 3, 4 in a list.

01:04:39.240 --> 01:04:43.980 align:middle line:84%
So what is the actual
loop going to do?

01:04:43.980 --> 01:04:48.050 align:middle line:84%
It's going to take whatever
is in L, double it.

01:04:48.050 --> 01:04:51.020 align:middle line:90%
So originally L is 1, 2, 3, 4.

01:04:51.020 --> 01:04:52.522 align:middle line:84%
The first time
through the loop is

01:04:52.522 --> 01:04:53.980 align:middle line:84%
going to create a
new object, which

01:04:53.980 --> 01:04:57.340 align:middle line:90%
is just L 1, 2, 3, 4 doubled.

01:04:57.340 --> 01:04:59.960 align:middle line:90%
I've concatenated L with itself.

01:04:59.960 --> 01:05:05.780 align:middle line:84%
And then I'm going to save it as
this new object with the name L

01:05:05.780 --> 01:05:08.500 align:middle line:90%
again.

01:05:08.500 --> 01:05:10.870 align:middle line:84%
That's the first time
through the loop.

01:05:10.870 --> 01:05:12.760 align:middle line:84%
Second time through
the loop, I'm

01:05:12.760 --> 01:05:15.760 align:middle line:84%
going to take whatever
L was mutated--

01:05:15.760 --> 01:05:17.570 align:middle line:90%
or whatever L was before.

01:05:17.570 --> 01:05:19.760 align:middle line:84%
Sorry, not mutated, but
whatever L was before.

01:05:19.760 --> 01:05:21.850 align:middle line:90%
So it's 1, 2, 3, 4, 1, 2, 3, 4.

01:05:21.850 --> 01:05:28.652 align:middle line:84%
Double that and save it
under the name L. Second time

01:05:28.652 --> 01:05:29.360 align:middle line:90%
through the loop.

01:05:29.360 --> 01:05:31.340 align:middle line:84%
Now, third time
through the loop,

01:05:31.340 --> 01:05:34.130 align:middle line:84%
I'm going to take
whatever L is right now.

01:05:34.130 --> 01:05:38.000 align:middle line:84%
So these two rows of
1, 2, 3, 4, 1, 2, 3, 4.

01:05:38.000 --> 01:05:44.140 align:middle line:84%
Double that and save
it under the name L.

01:05:44.140 --> 01:05:46.960 align:middle line:84%
And then the last
time through the loop,

01:05:46.960 --> 01:05:50.060 align:middle line:84%
I'm going to take
whatever L was before.

01:05:50.060 --> 01:05:53.390 align:middle line:84%
So these four rows of
1, 2, 3, 4, 1, 2, 3, 4,

01:05:53.390 --> 01:05:58.640 align:middle line:84%
double those, and save that
as the new L. And that's it.

01:05:58.640 --> 01:06:05.910 align:middle line:84%
This code does not
go to infinity.

01:06:05.910 --> 01:06:08.290 align:middle line:84%
Now, let's see why
exactly that is.

01:06:08.290 --> 01:06:10.770 align:middle line:90%
So this will help.

01:06:10.770 --> 01:06:13.830 align:middle line:84%
Originally, I've
got L is 1, 2, 3, 4.

01:06:13.830 --> 01:06:16.350 align:middle line:90%
So that's straightforward.

01:06:16.350 --> 01:06:21.460 align:middle line:84%
My loop variable e goes through
each element in this object.

01:06:21.460 --> 01:06:24.320 align:middle line:84%
So first it's going
to point to the 1.

01:06:24.320 --> 01:06:25.850 align:middle line:90%
So far the same.

01:06:25.850 --> 01:06:31.350 align:middle line:84%
L equals L plus L. Let's look
at the right hand side first.

01:06:31.350 --> 01:06:34.480 align:middle line:84%
This creates for
me a new object.

01:06:34.480 --> 01:06:36.820 align:middle line:84%
Remember, concatenation
creates for me a new object.

01:06:36.820 --> 01:06:38.490 align:middle line:90%
It doesn't mutate anything.

01:06:38.490 --> 01:06:42.720 align:middle line:84%
So in memory, I'm going to
get 1, 2, 3, 4, 1, 2, 3, 4.

01:06:42.720 --> 01:06:46.220 align:middle line:90%
I've doubled L with itself.

01:06:46.220 --> 01:06:48.370 align:middle line:90%
What is L equals going to do?

01:06:48.370 --> 01:06:52.110 align:middle line:90%


01:06:52.110 --> 01:06:55.150 align:middle line:84%
Do you remember we did a slide
like this, very similar to this.

01:06:55.150 --> 01:06:57.910 align:middle line:84%
It's like when we
reassigned the tuple.

01:06:57.910 --> 01:07:00.790 align:middle line:84%
The L equals will
actually take the binding

01:07:00.790 --> 01:07:04.990 align:middle line:84%
from my original object and
put it on the new object

01:07:04.990 --> 01:07:08.190 align:middle line:90%
that I just created.

01:07:08.190 --> 01:07:11.170 align:middle line:84%
Exactly that memory
diagram with the tuple.

01:07:11.170 --> 01:07:13.860 align:middle line:84%
I happened to have
the same name,

01:07:13.860 --> 01:07:15.950 align:middle line:84%
but it's pointing
to a new object.

01:07:15.950 --> 01:07:17.020 align:middle line:90%
Same here.

01:07:17.020 --> 01:07:18.900 align:middle line:84%
I happen to have
the same name, L,

01:07:18.900 --> 01:07:21.190 align:middle line:84%
but it's now pointing
to this new object.

01:07:21.190 --> 01:07:25.150 align:middle line:84%
The old object, this thing
that I'm iterating over,

01:07:25.150 --> 01:07:27.970 align:middle line:90%
I've lost the binding to it.

01:07:27.970 --> 01:07:29.980 align:middle line:84%
And really the
only way I can even

01:07:29.980 --> 01:07:31.690 align:middle line:84%
reference that old
object is through

01:07:31.690 --> 01:07:33.580 align:middle line:84%
this e, because that
e is still going

01:07:33.580 --> 01:07:37.770 align:middle line:84%
to go through this
old object element.

01:07:37.770 --> 01:07:39.180 align:middle line:90%
So that's the first time.

01:07:39.180 --> 01:07:40.530 align:middle line:90%
Yes, question.

01:07:40.530 --> 01:07:43.830 align:middle line:84%
STUDENT: Why does
e not [INAUDIBLE]??

01:07:43.830 --> 01:07:46.440 align:middle line:84%
Because you defined it
before you [INAUDIBLE]??

01:07:46.440 --> 01:07:50.430 align:middle line:84%
ANA BELL: Yes, you define it
to be the object in memory,

01:07:50.430 --> 01:07:55.240 align:middle line:84%
not the name L. So e is bound
to the object in memory.

01:07:55.240 --> 01:07:56.350 align:middle line:90%
That's this thing here.

01:07:56.350 --> 01:07:58.740 align:middle line:84%
That's why it was so important
to separate ourselves

01:07:58.740 --> 01:08:01.450 align:middle line:84%
from the object in
memory versus the name

01:08:01.450 --> 01:08:04.040 align:middle line:84%
we give an object, because that
name can change to anything,

01:08:04.040 --> 01:08:05.620 align:middle line:90%
to a bunch of other stuff.

01:08:05.620 --> 01:08:08.980 align:middle line:84%
But the object itself
remains in memory.

01:08:08.980 --> 01:08:11.880 align:middle line:84%
So then this becomes
pretty straightforward

01:08:11.880 --> 01:08:14.298 align:middle line:90%
if you understand that piece.

01:08:14.298 --> 01:08:15.840 align:middle line:84%
The first time
through the loop, I've

01:08:15.840 --> 01:08:18.279 align:middle line:84%
got L assigned to
this new object here.

01:08:18.279 --> 01:08:20.640 align:middle line:84%
I've lost the binding
to my original

01:08:20.640 --> 01:08:22.560 align:middle line:90%
list that I'm iterating over.

01:08:22.560 --> 01:08:24.960 align:middle line:90%
So when I print L, I print this.

01:08:24.960 --> 01:08:30.689 align:middle line:84%
Next time e increases to the
next element in my sequence.

01:08:30.689 --> 01:08:34.750 align:middle line:84%
L will double what
it currently is.

01:08:34.750 --> 01:08:36.590 align:middle line:84%
So it's currently
this thing here.

01:08:36.590 --> 01:08:38.890 align:middle line:90%
It's going to double to that.

01:08:38.890 --> 01:08:41.320 align:middle line:84%
And I'm going to lose the
binding from the original,

01:08:41.320 --> 01:08:43.180 align:middle line:84%
or not the original,
but this thing

01:08:43.180 --> 01:08:46.540 align:middle line:84%
that I had just bounded to,
to bind it to the next object

01:08:46.540 --> 01:08:49.370 align:middle line:90%
that I just created.

01:08:49.370 --> 01:08:51.540 align:middle line:84%
And then that's the second
time through the loop.

01:08:51.540 --> 01:08:52.640 align:middle line:90%
It looks like this.

01:08:52.640 --> 01:08:55.010 align:middle line:90%
Third time through the loop.

01:08:55.010 --> 01:08:58.880 align:middle line:84%
e increments by 1, to the
next value in my sequence.

01:08:58.880 --> 01:09:01.310 align:middle line:84%
I'm going to take
L plus L, so double

01:09:01.310 --> 01:09:05.970 align:middle line:90%
that previous data object.

01:09:05.970 --> 01:09:10.189 align:middle line:84%
Take the binding from that
previous object to the new one.

01:09:10.189 --> 01:09:13.620 align:middle line:90%
Increment e by one more.

01:09:13.620 --> 01:09:17.660 align:middle line:84%
And this will be the last
time E is going to change,

01:09:17.660 --> 01:09:20.510 align:middle line:84%
because after this, e
will have gone through all

01:09:20.510 --> 01:09:22.080 align:middle line:90%
the elements in its sequence.

01:09:22.080 --> 01:09:24.493 align:middle line:84%
It's gone through
the end of that list.

01:09:24.493 --> 01:09:25.910 align:middle line:84%
So the last time
through the loop,

01:09:25.910 --> 01:09:28.215 align:middle line:84%
I've doubled that
L, and I've lost

01:09:28.215 --> 01:09:30.590 align:middle line:84%
the binding from the previous
one, made it to the new one

01:09:30.590 --> 01:09:31.380 align:middle line:90%
and then that's it.

01:09:31.380 --> 01:09:31.880 align:middle line:90%
It's done.

01:09:31.880 --> 01:09:36.439 align:middle line:90%


01:09:36.439 --> 01:09:37.790 align:middle line:90%
Questions?

01:09:37.790 --> 01:09:39.390 align:middle line:90%
Is it straightforward?

01:09:39.390 --> 01:09:42.060 align:middle line:90%
Does the picture help all that?

01:09:42.060 --> 01:09:42.560 align:middle line:90%
OK.

01:09:42.560 --> 01:09:45.470 align:middle line:90%


01:09:45.470 --> 01:09:47.018 align:middle line:84%
One more thing I
want to mention,

01:09:47.018 --> 01:09:48.560 align:middle line:84%
and this is kind of
a preview of what

01:09:48.560 --> 01:09:51.109 align:middle line:90%
we're going to do next time.

01:09:51.109 --> 01:09:55.460 align:middle line:84%
One very useful operation
that you might want to do

01:09:55.460 --> 01:09:59.520 align:middle line:84%
is to take a list and
remove all of its elements.

01:09:59.520 --> 01:10:00.560 align:middle line:90%
Yeah, go ahead.

01:10:00.560 --> 01:10:01.430 align:middle line:90%
STUDENT: Sorry.

01:10:01.430 --> 01:10:06.042 align:middle line:84%
[INAUDIBLE] because usually
it stops before the last one.

01:10:06.042 --> 01:10:08.850 align:middle line:84%
ANA BELL: Oh, here
that's in range.

01:10:08.850 --> 01:10:11.210 align:middle line:84%
So here it's just iterating
through all the elements

01:10:11.210 --> 01:10:15.370 align:middle line:84%
in the sequence
going to every one.

01:10:15.370 --> 01:10:17.620 align:middle line:84%
So one useful operation
we might want to do

01:10:17.620 --> 01:10:21.400 align:middle line:84%
is to remove all the
elements in a list, but not--

01:10:21.400 --> 01:10:24.050 align:middle line:90%
sorry, but by mutating the list.

01:10:24.050 --> 01:10:27.710 align:middle line:84%
So we want to keep our
original list object.

01:10:27.710 --> 01:10:30.830 align:middle line:84%
We just want to basically clear
it out of all of its elements.

01:10:30.830 --> 01:10:34.730 align:middle line:84%
And so the command for that
has a pretty nice name.

01:10:34.730 --> 01:10:35.980 align:middle line:90%
It's called clear.

01:10:35.980 --> 01:10:39.320 align:middle line:84%
So if you want to take
a list L and clear it,

01:10:39.320 --> 01:10:44.380 align:middle line:84%
so to remove all the elements
inside it, you say L.clear.

01:10:44.380 --> 01:10:51.180 align:middle line:84%
And that mutates my
original list L to be empty.

01:10:51.180 --> 01:10:55.740 align:middle line:84%
So one thing that might help
with this mutation lecture

01:10:55.740 --> 01:10:57.540 align:middle line:84%
and figuring out
which object is which

01:10:57.540 --> 01:11:00.450 align:middle line:84%
and whether you've created a new
object or not is to figure out--

01:11:00.450 --> 01:11:04.260 align:middle line:84%
is to ask, how do I know that
this object is the object

01:11:04.260 --> 01:11:05.490 align:middle line:90%
that I'm mutating?

01:11:05.490 --> 01:11:08.640 align:middle line:84%
And to do that, we're actually
going to use this function

01:11:08.640 --> 01:11:09.990 align:middle line:90%
called ID.

01:11:09.990 --> 01:11:14.640 align:middle line:84%
And ID lets us get the
memory location or memory

01:11:14.640 --> 01:11:19.300 align:middle line:84%
object or the idea of the
object itself in memory.

01:11:19.300 --> 01:11:24.850 align:middle line:84%
So the code on the left is
code that takes in a list

01:11:24.850 --> 01:11:29.690 align:middle line:84%
L. We get its ID to see what
is this object in memory.

01:11:29.690 --> 01:11:30.800 align:middle line:90%
What's its number?

01:11:30.800 --> 01:11:32.060 align:middle line:90%
Append an 8 to it.

01:11:32.060 --> 01:11:34.540 align:middle line:84%
We're going to see
that the ID of this

01:11:34.540 --> 01:11:37.610 align:middle line:84%
is going to be the
same as the ID of this.

01:11:37.610 --> 01:11:39.910 align:middle line:84%
Because we're mutating
L. We're not adding it.

01:11:39.910 --> 01:11:40.990 align:middle line:90%
We're not changing it.

01:11:40.990 --> 01:11:42.820 align:middle line:90%
We're not creating a new object.

01:11:42.820 --> 01:11:46.417 align:middle line:84%
And then lastly, we're going to
clear it and check the ID again.

01:11:46.417 --> 01:11:49.000 align:middle line:84%
And you're going to see that the
ID is exactly the same in all

01:11:49.000 --> 01:11:50.770 align:middle line:90%
of these different cases.

01:11:50.770 --> 01:11:54.070 align:middle line:84%
So I'm doing this
just in the console

01:11:54.070 --> 01:11:55.460 align:middle line:90%
just to show you real quick.

01:11:55.460 --> 01:11:59.810 align:middle line:84%
So here I have 4, 5, 6 as
my L. Here's L 4, 5, 6.

01:11:59.810 --> 01:12:04.180 align:middle line:84%
The ID of it is
this number here.

01:12:04.180 --> 01:12:07.630 align:middle line:84%
We can just look at the last
three digits or whatever.

01:12:07.630 --> 01:12:08.860 align:middle line:90%
8, 0, 8.

01:12:08.860 --> 01:12:13.140 align:middle line:84%
Let's append an item
to the end of our list.

01:12:13.140 --> 01:12:17.190 align:middle line:90%
L mutated to contain that item.

01:12:17.190 --> 01:12:20.160 align:middle line:90%
The idea of L remains the same.

01:12:20.160 --> 01:12:21.160 align:middle line:90%
Ends in 8, 0, 8.

01:12:21.160 --> 01:12:23.200 align:middle line:84%
It's the exact same
object in memory.

01:12:23.200 --> 01:12:25.300 align:middle line:90%
We've mutated it.

01:12:25.300 --> 01:12:28.180 align:middle line:90%
L.clear.

01:12:28.180 --> 01:12:30.620 align:middle line:90%
L empty list.

01:12:30.620 --> 01:12:34.450 align:middle line:84%
I've removed all the elements
of L. And the idea of L

01:12:34.450 --> 01:12:36.950 align:middle line:84%
will show me that it's
this exact same object.

01:12:36.950 --> 01:12:41.780 align:middle line:84%
I'm just mutating this
same object in memory.

01:12:41.780 --> 01:12:47.360 align:middle line:84%
Let's do that again, except
in the new version instead

01:12:47.360 --> 01:12:51.120 align:middle line:84%
of using L.clear, I will say
L is equal to the empty list.

01:12:51.120 --> 01:12:55.360 align:middle line:84%
And this is also a really
common mistake to make.

01:12:55.360 --> 01:12:58.250 align:middle line:90%
So here I have L is 4, 5, 6.

01:12:58.250 --> 01:13:00.920 align:middle line:84%
Again, this is my L.
Let's get the idea of L.

01:13:00.920 --> 01:13:03.370 align:middle line:84%
It's going to be a new one,
because I've reassigned L

01:13:03.370 --> 01:13:04.610 align:middle line:90%
to this new list.

01:13:04.610 --> 01:13:08.060 align:middle line:90%
So this one ends in 3, 1, 2.

01:13:08.060 --> 01:13:11.690 align:middle line:84%
Again, let's do an
append just for fun.

01:13:11.690 --> 01:13:17.690 align:middle line:84%
The ID or L ID of L is
going to be, again, 3, 1, 2.

01:13:17.690 --> 01:13:20.390 align:middle line:84%
But now if I say L is
equal to the empty list,

01:13:20.390 --> 01:13:22.490 align:middle line:84%
this is exactly the
same as the situations

01:13:22.490 --> 01:13:25.860 align:middle line:84%
we've seen before with the tuple
and with that trick example

01:13:25.860 --> 01:13:26.730 align:middle line:90%
number 3.

01:13:26.730 --> 01:13:28.640 align:middle line:84%
When I say L is equal
to the empty list,

01:13:28.640 --> 01:13:31.070 align:middle line:84%
Python takes my name
L and assigns it

01:13:31.070 --> 01:13:34.130 align:middle line:84%
to this object that
is the empty list.

01:13:34.130 --> 01:13:37.740 align:middle line:84%
My original object, 4, 5,
6, 8 is still in memory.

01:13:37.740 --> 01:13:39.720 align:middle line:84%
I've just lost
the binding to it.

01:13:39.720 --> 01:13:44.850 align:middle line:90%
So here's L. It's an empty list.

01:13:44.850 --> 01:13:48.550 align:middle line:84%
But the idea of L is now
going to be different.

01:13:48.550 --> 01:13:52.750 align:middle line:84%
Originally, I was working
with this list at ID 312.

01:13:52.750 --> 01:13:55.230 align:middle line:84%
But after I said L is
equal to the empty list,

01:13:55.230 --> 01:13:58.170 align:middle line:84%
I've lost the binding
from that old list

01:13:58.170 --> 01:14:02.970 align:middle line:84%
and rebound my name L
to this new empty list.

01:14:02.970 --> 01:14:06.715 align:middle line:84%
And you can see this using
this ID, which is pretty cool.

01:14:06.715 --> 01:14:09.370 align:middle line:90%


01:14:09.370 --> 01:14:10.790 align:middle line:90%
OK, quick summary.

01:14:10.790 --> 01:14:14.350 align:middle line:84%
So we saw lists and
tuples as a way for us

01:14:14.350 --> 01:14:16.420 align:middle line:84%
to create these compound
data structures that

01:14:16.420 --> 01:14:19.310 align:middle line:84%
can contain any kind of
object as their elements.

01:14:19.310 --> 01:14:20.600 align:middle line:90%
Tuples are immutable.

01:14:20.600 --> 01:14:24.010 align:middle line:84%
So for things that
don't change, they're

01:14:24.010 --> 01:14:27.430 align:middle line:84%
very useful, like country,
latitude, longitude.

01:14:27.430 --> 01:14:28.810 align:middle line:90%
Those things won't change.

01:14:28.810 --> 01:14:32.620 align:middle line:84%
Or the word that appears on a
page number and a line number,

01:14:32.620 --> 01:14:35.260 align:middle line:90%
something like that.

01:14:35.260 --> 01:14:39.040 align:middle line:84%
Lists are mutable objects,
so you use them in situations

01:14:39.040 --> 01:14:41.220 align:middle line:84%
where you need that
dynamic aspect.

01:14:41.220 --> 01:14:43.253 align:middle line:84%
So if you want to maintain
a list of employees,

01:14:43.253 --> 01:14:44.920 align:middle line:84%
you want to maintain
a list of students,

01:14:44.920 --> 01:14:48.140 align:middle line:84%
a list of grocery items
or things in your fridge,

01:14:48.140 --> 01:14:50.062 align:middle line:84%
those are really
good situations where

01:14:50.062 --> 01:14:52.520 align:middle line:84%
you'd want to list, because
things are constantly changing.

01:14:52.520 --> 01:14:54.550 align:middle line:84%
You don't want to make
copies of everything

01:14:54.550 --> 01:14:59.110 align:middle line:84%
all the time because it becomes
very inefficient to do so.

01:14:59.110 --> 01:15:03.130 align:middle line:84%
So next lecture, we will
continue with tricky examples.

01:15:03.130 --> 01:15:05.140 align:middle line:90%
And we'll also have a quiz.

01:15:05.140 --> 01:15:07.800 align:middle line:84%
Remember, quizzes
are now on Mondays.

01:15:07.800 --> 01:15:13.000 align:middle line:90%